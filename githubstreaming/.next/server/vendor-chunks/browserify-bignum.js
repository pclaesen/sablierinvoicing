/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/browserify-bignum";
exports.ids = ["vendor-chunks/browserify-bignum"];
exports.modules = {

/***/ "(ssr)/./node_modules/browserify-bignum/bignumber.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-bignum/bignumber.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/* bignumber.js v1.3.0 https://github.com/MikeMcl/bignumber.js/LICENCE */\n\n/*jslint bitwise: true, eqeq: true, plusplus: true, sub: true, white: true, maxerr: 500 */\n/*global module */\n\n/*\n  bignumber.js v1.3.0\n  A JavaScript library for arbitrary-precision arithmetic.\n  https://github.com/MikeMcl/bignumber.js\n  Copyright (c) 2012 Michael Mclaughlin <M8ch88l@gmail.com>\n  MIT Expat Licence\n*/\n\n/*********************************** DEFAULTS ************************************/\n\n/*\n * The default values below must be integers within the stated ranges (inclusive).\n * Most of these values can be changed during run-time using BigNumber.config().\n */\n\n/*\n * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP,\n * MAX_EXP, and the argument to toFixed, toPrecision and toExponential, beyond\n * which an exception is thrown (if ERRORS is true).\n */\nvar MAX = 1E9,                                   // 0 to 1e+9\n\n    // Limit of magnitude of exponent argument to toPower.\n    MAX_POWER = 1E6,                             // 1 to 1e+6\n\n    // The maximum number of decimal places for operations involving division.\n    DECIMAL_PLACES = 20,                         // 0 to MAX\n\n    /*\n     * The rounding mode used when rounding to the above decimal places, and when\n     * using toFixed, toPrecision and toExponential, and round (default value).\n     * UP         0 Away from zero.\n     * DOWN       1 Towards zero.\n     * CEIL       2 Towards +Infinity.\n     * FLOOR      3 Towards -Infinity.\n     * HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n     * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n     * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n     * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n     * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n     */\n    ROUNDING_MODE = 4,                           // 0 to 8\n\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n\n    // The exponent value at and beneath which toString returns exponential notation.\n    // Number type: -7\n    TO_EXP_NEG = -7,                             // 0 to -MAX\n\n    // The exponent value at and above which toString returns exponential notation.\n    // Number type: 21\n    TO_EXP_POS = 21,                             // 0 to MAX\n\n    // RANGE : [MIN_EXP, MAX_EXP]\n\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // Number type: -324  (5e-324)\n    MIN_EXP = -MAX,                              // -1 to -MAX\n\n    // The maximum exponent value, above which overflow to Infinity occurs.\n    // Number type:  308  (1.7976931348623157e+308)\n    MAX_EXP = MAX,                               // 1 to MAX\n\n    // Whether BigNumber Errors are ever thrown.\n    // CHANGE parseInt to parseFloat if changing ERRORS to false.\n    ERRORS = true,                               // true or false\n    parse = parseInt,                            // parseInt or parseFloat\n\n/***********************************************************************************/\n\n    P = BigNumber.prototype,\n    DIGITS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',\n    outOfRange,\n    id = 0,\n    isValid = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\n    trim = String.prototype.trim || function () {return this.replace(/^\\s+|\\s+$/g, '')},\n    ONE = BigNumber(1);\n\n\n// CONSTRUCTOR\n\n\n/*\n * The exported function.\n * Create and return a new instance of a BigNumber object.\n *\n * n {number|string|BigNumber} A numeric value.\n * [b] {number} The base of n. Integer, 2 to 64 inclusive.\n */\nfunction BigNumber( n, b ) {\n    var e, i, isNum, digits, valid, orig,\n        x = this;\n\n    // Enable constructor usage without new.\n    if ( !(x instanceof BigNumber) ) {\n        return new BigNumber( n, b )\n    }\n\n    // Duplicate.\n    if ( n instanceof BigNumber ) {\n        id = 0;\n\n        // e is undefined.\n        if ( b !== e ) {\n            n += ''\n        } else {\n            x['s'] = n['s'];\n            x['e'] = n['e'];\n            x['c'] = ( n = n['c'] ) ? n.slice() : n;\n            return;\n        }\n    }\n\n    // If number, check if minus zero.\n    if ( typeof n != 'string' ) {\n        n = ( isNum = typeof n == 'number' ||\n            Object.prototype.toString.call(n) == '[object Number]' ) &&\n                n === 0 && 1 / n < 0 ? '-0' : n + '';\n    }\n\n    orig = n;\n\n    if ( b === e && isValid.test(n) ) {\n\n        // Determine sign.\n        x['s'] = n.charAt(0) == '-' ? ( n = n.slice(1), -1 ) : 1;\n\n    // Either n is not a valid BigNumber or a base has been specified.\n    } else {\n\n        // Enable exponential notation to be used with base 10 argument.\n        // Ensure return value is rounded to DECIMAL_PLACES as with other bases.\n        if ( b == 10 ) {\n\n            return setMode( n, DECIMAL_PLACES, ROUNDING_MODE );\n        }\n\n        n = trim.call(n).replace( /^\\+(?!-)/, '' );\n\n        x['s'] = n.charAt(0) == '-' ? ( n = n.replace( /^-(?!-)/, '' ), -1 ) : 1;\n\n        if ( b != null ) {\n\n            if ( ( b == (b | 0) || !ERRORS ) &&\n              !( outOfRange = !( b >= 2 && b < 65 ) ) ) {\n\n                digits = '[' + DIGITS.slice( 0, b = b | 0 ) + ']+';\n\n                // Before non-decimal number validity test and base conversion\n                // remove the `.` from e.g. '1.', and replace e.g. '.1' with '0.1'.\n                n = n.replace( /\\.$/, '' ).replace( /^\\./, '0.' );\n\n                // Any number in exponential form will fail due to the e+/-.\n                if ( valid = new RegExp(\n                  '^' + digits + '(?:\\\\.' + digits + ')?$', b < 37 ? 'i' : '' ).test(n) ) {\n\n                    if ( isNum ) {\n\n                        if ( n.replace( /^0\\.0*|\\./, '' ).length > 15 ) {\n\n                            // 'new BigNumber() number type has more than 15 significant digits: {n}'\n                            ifExceptionsThrow( orig, 0 );\n                        }\n\n                        // Prevent later check for length on converted number.\n                        isNum = !isNum;\n                    }\n                    n = convert( n, 10, b, x['s'] );\n\n                } else if ( n != 'Infinity' && n != 'NaN' ) {\n\n                    // 'new BigNumber() not a base {b} number: {n}'\n                    ifExceptionsThrow( orig, 1, b );\n                    n = 'NaN';\n                }\n            } else {\n\n                // 'new BigNumber() base not an integer: {b}'\n                // 'new BigNumber() base out of range: {b}'\n                ifExceptionsThrow( b, 2 );\n\n                // Ignore base.\n                valid = isValid.test(n);\n            }\n        } else {\n            valid = isValid.test(n);\n        }\n\n        if ( !valid ) {\n\n            // Infinity/NaN\n            x['c'] = x['e'] = null;\n\n            // NaN\n            if ( n != 'Infinity' ) {\n\n                // No exception on NaN.\n                if ( n != 'NaN' ) {\n\n                    // 'new BigNumber() not a number: {n}'\n                    ifExceptionsThrow( orig, 3 );\n                }\n                x['s'] = null;\n            }\n            id = 0;\n\n            return;\n        }\n    }\n\n    // Decimal point?\n    if ( ( e = n.indexOf('.') ) > -1 ) {\n        n = n.replace( '.', '' );\n    }\n\n    // Exponential form?\n    if ( ( i = n.search( /e/i ) ) > 0 ) {\n\n        // Determine exponent.\n        if ( e < 0 ) {\n            e = i;\n        }\n        e += +n.slice( i + 1 );\n        n = n.substring( 0, i );\n\n    } else if ( e < 0 ) {\n\n        // Integer.\n        e = n.length;\n    }\n\n    // Determine leading zeros.\n    for ( i = 0; n.charAt(i) == '0'; i++ ) {\n    }\n\n    b = n.length;\n\n    // Disallow numbers with over 15 significant digits if number type.\n    if ( isNum && b > 15 && n.slice(i).length > 15 ) {\n\n        // 'new BigNumber() number type has more than 15 significant digits: {n}'\n        ifExceptionsThrow( orig, 0 );\n    }\n    id = 0;\n\n    // Overflow?\n    if ( ( e -= i + 1 ) > MAX_EXP ) {\n\n        // Infinity.\n        x['c'] = x['e'] = null;\n\n    // Zero or underflow?\n    } else if ( i == b || e < MIN_EXP ) {\n\n        // Zero.\n        x['c'] = [ x['e'] = 0 ];\n    } else {\n\n        // Determine trailing zeros.\n        for ( ; n.charAt(--b) == '0'; ) {\n        }\n\n        x['e'] = e;\n        x['c'] = [];\n\n        // Convert string to array of digits (without leading and trailing zeros).\n        for ( e = 0; i <= b; x['c'][e++] = +n.charAt(i++) ) {\n        }\n    }\n}\n\n\n// CONSTRUCTOR PROPERTIES/METHODS\n\n\nBigNumber['ROUND_UP'] = 0;\nBigNumber['ROUND_DOWN'] = 1;\nBigNumber['ROUND_CEIL'] = 2;\nBigNumber['ROUND_FLOOR'] = 3;\nBigNumber['ROUND_HALF_UP'] = 4;\nBigNumber['ROUND_HALF_DOWN'] = 5;\nBigNumber['ROUND_HALF_EVEN'] = 6;\nBigNumber['ROUND_HALF_CEIL'] = 7;\nBigNumber['ROUND_HALF_FLOOR'] = 8;\n\n/*\n * Create an instance from a Buffer\n */\nBigNumber['fromBuffer'] = function (buf, opts) {\n\n    if (!opts) opts = {};\n\n    var endian = { 1 : 'big', '-1' : 'little' }[opts.endian]\n        || opts.endian || 'big'\n    ;\n\n    var size = opts.size === 'auto' ? Math.ceil(buf.length) : (opts.size || 1);\n\n    if (buf.length % size !== 0) {\n        throw new RangeError('Buffer length (' + buf.length + ')'\n            + ' must be a multiple of size (' + size + ')'\n        );\n    }\n\n    var hex = [];\n    for (var i = 0; i < buf.length; i += size) {\n        var chunk = [];\n        for (var j = 0; j < size; j++) {\n            chunk.push(buf[\n                i + (endian === 'big' ? j : (size - j - 1))\n            ]);\n        }\n\n        hex.push(chunk\n            .map(function (c) {\n                return (c < 16 ? '0' : '') + c.toString(16);\n            })\n            .join('')\n        );\n    }\n\n    return BigNumber(hex.join(''), 16);\n\n};\n\n/*\n * Configure infrequently-changing library-wide settings.\n *\n * Accept an object or an argument list, with one or many of the following\n * properties or parameters respectively:\n * [ DECIMAL_PLACES [, ROUNDING_MODE [, EXPONENTIAL_AT [, RANGE [, ERRORS ]]]]]\n *\n * E.g.\n * BigNumber.config(20, 4) is equivalent to\n * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\n * Ignore properties/parameters set to null or undefined.\n *\n * Return an object with the properties current values.\n */\nBigNumber['config'] = function () {\n    var v, p,\n        i = 0,\n        r = {},\n        a = arguments,\n        o = a[0],\n        c = 'config',\n        inRange = function ( n, lo, hi ) {\n          return !( ( outOfRange = n < lo || n > hi ) ||\n            parse(n) != n && n !== 0 );\n        },\n        has = o && typeof o == 'object'\n          ? function () {if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null}\n          : function () {if ( a.length > i ) return ( v = a[i++] ) != null};\n\n    // [DECIMAL_PLACES] {number} Integer, 0 to MAX inclusive.\n    if ( has( p = 'DECIMAL_PLACES' ) ) {\n\n        if ( inRange( v, 0, MAX ) ) {\n            DECIMAL_PLACES = v | 0;\n        } else {\n\n            // 'config() DECIMAL_PLACES not an integer: {v}'\n            // 'config() DECIMAL_PLACES out of range: {v}'\n            ifExceptionsThrow( v, p, c );\n        }\n    }\n    r[p] = DECIMAL_PLACES;\n\n    // [ROUNDING_MODE] {number} Integer, 0 to 8 inclusive.\n    if ( has( p = 'ROUNDING_MODE' ) ) {\n\n        if ( inRange( v, 0, 8 ) ) {\n            ROUNDING_MODE = v | 0;\n        } else {\n\n            // 'config() ROUNDING_MODE not an integer: {v}'\n            // 'config() ROUNDING_MODE out of range: {v}'\n            ifExceptionsThrow( v, p, c );\n        }\n    }\n    r[p] = ROUNDING_MODE;\n\n    /*\n     * [EXPONENTIAL_AT] {number|number[]} Integer, -MAX to MAX inclusive or\n     * [ integer -MAX to 0 inclusive, 0 to MAX inclusive ].\n     */\n    if ( has( p = 'EXPONENTIAL_AT' ) ) {\n\n        if ( inRange( v, -MAX, MAX ) ) {\n            TO_EXP_NEG = -( TO_EXP_POS = ~~( v < 0 ? -v : +v ) );\n        } else if ( !outOfRange && v && inRange( v[0], -MAX, 0 ) &&\n          inRange( v[1], 0, MAX ) ) {\n            TO_EXP_NEG = ~~v[0];\n            TO_EXP_POS = ~~v[1];\n        } else {\n\n            // 'config() EXPONENTIAL_AT not an integer or not [integer, integer]: {v}'\n            // 'config() EXPONENTIAL_AT out of range or not [negative, positive: {v}'\n            ifExceptionsThrow( v, p, c, 1 );\n        }\n    }\n    r[p] = [ TO_EXP_NEG, TO_EXP_POS ];\n\n    /*\n     * [RANGE][ {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n     * [ integer -MAX to -1 inclusive, integer 1 to MAX inclusive ].\n     */\n    if ( has( p = 'RANGE' ) ) {\n\n        if ( inRange( v, -MAX, MAX ) && ~~v ) {\n            MIN_EXP = -( MAX_EXP = ~~( v < 0 ? -v : +v ) );\n        } else if ( !outOfRange && v && inRange( v[0], -MAX, -1 ) &&\n          inRange( v[1], 1, MAX ) ) {\n            MIN_EXP = ~~v[0], MAX_EXP = ~~v[1];\n        } else {\n\n            // 'config() RANGE not a non-zero integer or not [integer, integer]: {v}'\n            // 'config() RANGE out of range or not [negative, positive: {v}'\n            ifExceptionsThrow( v, p, c, 1, 1 );\n        }\n    }\n    r[p] = [ MIN_EXP, MAX_EXP ];\n\n    // [ERRORS] {boolean|number} true, false, 1 or 0.\n    if ( has( p = 'ERRORS' ) ) {\n\n        if ( v === !!v || v === 1 || v === 0 ) {\n            parse = ( outOfRange = id = 0, ERRORS = !!v )\n              ? parseInt\n              : parseFloat;\n        } else {\n\n            // 'config() ERRORS not a boolean or binary digit: {v}'\n            ifExceptionsThrow( v, p, c, 0, 0, 1 );\n        }\n    }\n    r[p] = ERRORS;\n\n    return r;\n};\n\n\n// PRIVATE FUNCTIONS\n\n\n// Assemble error messages. Throw BigNumber Errors.\nfunction ifExceptionsThrow( arg, i, j, isArray, isRange, isErrors) {\n\n    if ( ERRORS ) {\n        var error,\n            method = ['new BigNumber', 'cmp', 'div', 'eq', 'gt', 'gte', 'lt',\n                 'lte', 'minus', 'mod', 'plus', 'times', 'toFr'\n                ][ id ? id < 0 ? -id : id : 1 / id < 0 ? 1 : 0 ] + '()',\n            message = outOfRange ? ' out of range' : ' not a' +\n              ( isRange ? ' non-zero' : 'n' ) + ' integer';\n\n        message = ( [\n            method + ' number type has more than 15 significant digits',\n            method + ' not a base ' + j + ' number',\n            method + ' base' + message,\n            method + ' not a number' ][i] ||\n              j + '() ' + i + ( isErrors\n                ? ' not a boolean or binary digit'\n                : message + ( isArray\n                  ? ' or not [' + ( outOfRange\n                    ? ' negative, positive'\n                    : ' integer, integer' ) + ' ]'\n                  : '' ) ) ) + ': ' + arg;\n\n        outOfRange = id = 0;\n        error = new Error(message);\n        error['name'] = 'BigNumber Error';\n\n        throw error;\n    }\n}\n\n\n/*\n * Convert a numeric string of baseIn to a numeric string of baseOut.\n */\nfunction convert( nStr, baseOut, baseIn, sign ) {\n    var e, dvs, dvd, nArr, fracArr, fracBN;\n\n    // Convert string of base bIn to an array of numbers of baseOut.\n    // Eg. strToArr('255', 10) where baseOut is 16, returns [15, 15].\n    // Eg. strToArr('ff', 16)  where baseOut is 10, returns [2, 5, 5].\n    function strToArr( str, bIn ) {\n        var j,\n            i = 0,\n            strL = str.length,\n            arrL,\n            arr = [0];\n\n        for ( bIn = bIn || baseIn; i < strL; i++ ) {\n\n            for ( arrL = arr.length, j = 0; j < arrL; arr[j] *= bIn, j++ ) {\n            }\n\n            for ( arr[0] += DIGITS.indexOf( str.charAt(i) ), j = 0;\n                  j < arr.length;\n                  j++ ) {\n\n                if ( arr[j] > baseOut - 1 ) {\n\n                    if ( arr[j + 1] == null ) {\n                        arr[j + 1] = 0;\n                    }\n                    arr[j + 1] += arr[j] / baseOut ^ 0;\n                    arr[j] %= baseOut;\n                }\n            }\n        }\n\n        return arr.reverse();\n    }\n\n    // Convert array to string.\n    // E.g. arrToStr( [9, 10, 11] ) becomes '9ab' (in bases above 11).\n    function arrToStr( arr ) {\n        var i = 0,\n            arrL = arr.length,\n            str = '';\n\n        for ( ; i < arrL; str += DIGITS.charAt( arr[i++] ) ) {\n        }\n\n        return str;\n    }\n\n    if ( baseIn < 37 ) {\n        nStr = nStr.toLowerCase();\n    }\n\n    /*\n     * If non-integer convert integer part and fraction part separately.\n     * Convert the fraction part as if it is an integer than use division to\n     * reduce it down again to a value less than one.\n     */\n    if ( ( e = nStr.indexOf( '.' ) ) > -1 ) {\n\n        /*\n         * Calculate the power to which to raise the base to get the number\n         * to divide the fraction part by after it has been converted as an\n         * integer to the required base.\n         */\n        e = nStr.length - e - 1;\n\n        // Use toFixed to avoid possible exponential notation.\n        dvs = strToArr( new BigNumber(baseIn)['pow'](e)['toF'](), 10 );\n\n        nArr = nStr.split('.');\n\n        // Convert the base of the fraction part (as integer).\n        dvd = strToArr( nArr[1] );\n\n        // Convert the base of the integer part.\n        nArr = strToArr( nArr[0] );\n\n        // Result will be a BigNumber with a value less than 1.\n        fracBN = divide( dvd, dvs, dvd.length - dvs.length, sign, baseOut,\n          // Is least significant digit of integer part an odd number?\n          nArr[nArr.length - 1] & 1 );\n\n        fracArr = fracBN['c'];\n\n        // e can be <= 0  ( if e == 0, fracArr is [0] or [1] ).\n        if ( e = fracBN['e'] ) {\n\n            // Append zeros according to the exponent of the result.\n            for ( ; ++e; fracArr.unshift(0) ) {\n            }\n\n            // Append the fraction part to the converted integer part.\n            nStr = arrToStr(nArr) + '.' + arrToStr(fracArr);\n\n        // fracArr is [1].\n        // Fraction digits rounded up, so increment last digit of integer part.\n        } else if ( fracArr[0] ) {\n\n            if ( nArr[ e = nArr.length - 1 ] < baseOut - 1 ) {\n                ++nArr[e];\n                nStr = arrToStr(nArr);\n            } else {\n                nStr = new BigNumber( arrToStr(nArr),\n                  baseOut )['plus'](ONE)['toS'](baseOut);\n            }\n\n        // fracArr is [0]. No fraction digits.\n        } else {\n            nStr = arrToStr(nArr);\n        }\n    } else {\n\n        // Simple integer. Convert base.\n        nStr = arrToStr( strToArr(nStr) );\n    }\n\n    return nStr;\n}\n\n\n// Perform division in the specified base. Called by div and convert.\nfunction divide( dvd, dvs, exp, s, base, isOdd ) {\n    var dvsL, dvsT, next, cmp, remI,\n        dvsZ = dvs.slice(),\n        dvdI = dvsL = dvs.length,\n        dvdL = dvd.length,\n        rem = dvd.slice( 0, dvsL ),\n        remL = rem.length,\n        quo = new BigNumber(ONE),\n        qc = quo['c'] = [],\n        qi = 0,\n        dig = DECIMAL_PLACES + ( quo['e'] = exp ) + 1;\n\n    quo['s'] = s;\n    s = dig < 0 ? 0 : dig;\n\n    // Add zeros to make remainder as long as divisor.\n    for ( ; remL++ < dvsL; rem.push(0) ) {\n    }\n\n    // Create version of divisor with leading zero.\n    dvsZ.unshift(0);\n\n    do {\n\n        // 'next' is how many times the divisor goes into the current remainder.\n        for ( next = 0; next < base; next++ ) {\n\n            // Compare divisor and remainder.\n            if ( dvsL != ( remL = rem.length ) ) {\n                cmp = dvsL > remL ? 1 : -1;\n            } else {\n                for ( remI = -1, cmp = 0; ++remI < dvsL; ) {\n\n                    if ( dvs[remI] != rem[remI] ) {\n                        cmp = dvs[remI] > rem[remI] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n\n            // Subtract divisor from remainder (if divisor < remainder).\n            if ( cmp < 0 ) {\n\n                // Remainder cannot be more than one digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for ( dvsT = remL == dvsL ? dvs : dvsZ; remL; ) {\n\n                    if ( rem[--remL] < dvsT[remL] ) {\n\n                        for ( remI = remL;\n                          remI && !rem[--remI];\n                            rem[remI] = base - 1 ) {\n                        }\n                        --rem[remI];\n                        rem[remL] += base;\n                    }\n                    rem[remL] -= dvsT[remL];\n                }\n                for ( ; !rem[0]; rem.shift() ) {\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Add the 'next' digit to the result array.\n        qc[qi++] = cmp ? next : ++next;\n\n        // Update the remainder.\n        rem[0] && cmp\n          ? ( rem[remL] = dvd[dvdI] || 0 )\n          : ( rem = [ dvd[dvdI] ] );\n\n    } while ( ( dvdI++ < dvdL || rem[0] != null ) && s-- );\n\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if ( !qc[0] && qi != 1 ) {\n\n        // There can't be more than one zero.\n        --quo['e'];\n        qc.shift();\n    }\n\n    // Round?\n    if ( qi > dig ) {\n        rnd( quo, DECIMAL_PLACES, base, isOdd, rem[0] != null );\n    }\n\n    // Overflow?\n    if ( quo['e'] > MAX_EXP ) {\n\n        // Infinity.\n        quo['c'] = quo['e'] = null;\n\n    // Underflow?\n    } else if ( quo['e'] < MIN_EXP ) {\n\n        // Zero.\n        quo['c'] = [quo['e'] = 0];\n    }\n\n    return quo;\n}\n\n\n/*\n * Return a string representing the value of BigNumber n in normal or\n * exponential notation rounded to the specified decimal places or\n * significant digits.\n * Called by toString, toExponential (exp 1), toFixed, and toPrecision (exp 2).\n * d is the index (with the value in normal notation) of the digit that may be\n * rounded up.\n */\nfunction format( n, d, exp ) {\n\n    // Initially, i is the number of decimal places required.\n    var i = d - (n = new BigNumber(n))['e'],\n        c = n['c'];\n\n    // +-Infinity or NaN?\n    if ( !c ) {\n        return n['toS']();\n    }\n\n    // Round?\n    if ( c.length > ++d ) {\n        rnd( n, i, 10 );\n    }\n\n    // Recalculate d if toFixed as n['e'] may have changed if value rounded up.\n    i = c[0] == 0 ? i + 1 : exp ? d : n['e'] + i + 1;\n\n    // Append zeros?\n    for ( ; c.length < i; c.push(0) ) {\n    }\n    i = n['e'];\n\n    /*\n     * toPrecision returns exponential notation if the number of significant\n     * digits specified is less than the number of digits necessary to\n     * represent the integer part of the value in normal notation.\n     */\n    return exp == 1 || exp == 2 && ( --d < i || i <= TO_EXP_NEG )\n\n      // Exponential notation.\n      ? ( n['s'] < 0 && c[0] ? '-' : '' ) + ( c.length > 1\n        ? ( c.splice( 1, 0, '.' ), c.join('') )\n        : c[0] ) + ( i < 0 ? 'e' : 'e+' ) + i\n\n      // Normal notation.\n      : n['toS']();\n}\n\n\n// Round if necessary.\n// Called by divide, format, setMode and sqrt.\nfunction rnd( x, dp, base, isOdd, r ) {\n    var xc = x['c'],\n        isNeg = x['s'] < 0,\n        half = base / 2,\n        i = x['e'] + dp + 1,\n\n        // 'next' is the digit after the digit that may be rounded up.\n        next = xc[i],\n\n        /*\n         * 'more' is whether there are digits after 'next'.\n         * E.g.\n         * 0.005 (e = -3) to be rounded to 0 decimal places (dp = 0) gives i = -2\n         * The 'next' digit is zero, and there ARE 'more' digits after it.\n         * 0.5 (e = -1) dp = 0 gives i = 0\n         * The 'next' digit is 5 and there are no 'more' digits after it.\n         */\n        more = r || i < 0 || xc[i + 1] != null;\n\n    r = ROUNDING_MODE < 4\n      ? ( next != null || more ) &&\n        ( ROUNDING_MODE == 0 ||\n           ROUNDING_MODE == 2 && !isNeg ||\n             ROUNDING_MODE == 3 && isNeg )\n      : next > half || next == half &&\n        ( ROUNDING_MODE == 4 || more ||\n\n          /*\n           * isOdd is used in base conversion and refers to the least significant\n           * digit of the integer part of the value to be converted. The fraction\n           * part is rounded by this method separately from the integer part.\n           */\n          ROUNDING_MODE == 6 && ( xc[i - 1] & 1 || !dp && isOdd ) ||\n            ROUNDING_MODE == 7 && !isNeg ||\n              ROUNDING_MODE == 8 && isNeg );\n\n    if ( i < 1 || !xc[0] ) {\n        xc.length = 0;\n        xc.push(0);\n\n        if ( r ) {\n\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n            xc[0] = 1;\n            x['e'] = -dp;\n        } else {\n\n            // Zero.\n            x['e'] = 0;\n        }\n\n        return x;\n    }\n\n    // Remove any digits after the required decimal places.\n    xc.length = i--;\n\n    // Round up?\n    if ( r ) {\n\n        // Rounding up may mean the previous digit has to be rounded up and so on.\n        for ( --base; ++xc[i] > base; ) {\n            xc[i] = 0;\n\n            if ( !i-- ) {\n                ++x['e'];\n                xc.unshift(1);\n            }\n        }\n    }\n\n    // Remove trailing zeros.\n    for ( i = xc.length; !xc[--i]; xc.pop() ) {\n    }\n\n    return x;\n}\n\n\n// Round after setting the appropriate rounding mode.\n// Handles ceil, floor and round.\nfunction setMode( x, dp, rm ) {\n    var r = ROUNDING_MODE;\n\n    ROUNDING_MODE = rm;\n    x = new BigNumber(x);\n    x['c'] && rnd( x, dp, 10 );\n    ROUNDING_MODE = r;\n\n    return x;\n}\n\n\n// PROTOTYPE/INSTANCE METHODS\n\n\n/*\n * Return a new BigNumber whose value is the absolute value of this BigNumber.\n */\nP['abs'] = P['absoluteValue'] = function () {\n    var x = new BigNumber(this);\n\n    if ( x['s'] < 0 ) {\n        x['s'] = 1;\n    }\n\n    return x;\n};\n\n/*\n * Return the bit length of the number.\n */\nP['bitLength'] = function () {\n    return this.toString(2).length;\n};\n\n\n/*\n * Return a new BigNumber whose value is the value of this BigNumber\n * rounded to a whole number in the direction of Infinity.\n */\nP['ceil'] = function () {\n    return setMode( this, 0, 2 );\n};\n\n\n/*\n * Return\n * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\n * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\n * 0 if they have the same value,\n * or null if the value of either is NaN.\n */\nP['comparedTo'] = P['cmp'] = function ( y, b ) {\n    var a,\n        x = this,\n        xc = x['c'],\n        yc = ( id = -id, y = new BigNumber( y, b ) )['c'],\n        i = x['s'],\n        j = y['s'],\n        k = x['e'],\n        l = y['e'];\n\n    // Either NaN?\n    if ( !i || !j ) {\n        return null;\n    }\n\n    a = xc && !xc[0], b = yc && !yc[0];\n\n    // Either zero?\n    if ( a || b ) {\n        return a ? b ? 0 : -j : i;\n    }\n\n    // Signs differ?\n    if ( i != j ) {\n        return i;\n    }\n\n    // Either Infinity?\n    if ( a = i < 0, b = k == l, !xc || !yc ) {\n        return b ? 0 : !xc ^ a ? 1 : -1;\n    }\n\n    // Compare exponents.\n    if ( !b ) {\n        return k > l ^ a ? 1 : -1;\n    }\n\n    // Compare digit by digit.\n    for ( i = -1,\n          j = ( k = xc.length ) < ( l = yc.length ) ? k : l;\n          ++i < j; ) {\n\n        if ( xc[i] != yc[i] ) {\n            return xc[i] > yc[i] ^ a ? 1 : -1;\n        }\n    }\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\n};\n\n\n/*\n *  n / 0 = I\n *  n / N = N\n *  n / I = 0\n *  0 / n = 0\n *  0 / 0 = N\n *  0 / N = N\n *  0 / I = 0\n *  N / n = N\n *  N / 0 = N\n *  N / N = N\n *  N / I = N\n *  I / n = I\n *  I / 0 = I\n *  I / N = N\n *  I / I = N\n *\n * Return a new BigNumber whose value is the value of this BigNumber\n * divided by the value of BigNumber(y, b), rounded according to\n * DECIMAL_PLACES and ROUNDING_MODE.\n */\nP['dividedBy'] = P['div'] = function ( y, b ) {\n    var xc = this['c'],\n        xe = this['e'],\n        xs = this['s'],\n        yc = ( id = 2, y = new BigNumber( y, b ) )['c'],\n        ye = y['e'],\n        ys = y['s'],\n        s = xs == ys ? 1 : -1;\n\n    // Either NaN/Infinity/0?\n    return !xe && ( !xc || !xc[0] ) || !ye && ( !yc || !yc[0] )\n\n      // Either NaN?\n      ? new BigNumber( !xs || !ys ||\n\n        // Both 0 or both Infinity?\n        ( xc ? yc && xc[0] == yc[0] : !yc )\n\n          // Return NaN.\n          ? NaN\n\n          // x is 0 or y is Infinity?\n          : xc && xc[0] == 0 || !yc\n\n            // Return +-0.\n            ? s * 0\n\n            // y is 0. Return +-Infinity.\n            : s / 0 )\n\n      : divide( xc, yc, xe - ye, s, 10 );\n};\n\n\n/*\n * Return true if the value of this BigNumber is equal to the value of\n * BigNumber(n, b), otherwise returns false.\n */\nP['equals'] = P['eq'] = function ( n, b ) {\n    id = 3;\n    return this['cmp']( n, b ) === 0;\n};\n\n\n/*\n * Return a new BigNumber whose value is the value of this BigNumber\n * rounded to a whole number in the direction of -Infinity.\n */\nP['floor'] = function () {\n    return setMode( this, 0, 3 );\n};\n\n\n/*\n * Return true if the value of this BigNumber is greater than the value of\n * BigNumber(n, b), otherwise returns false.\n */\nP['greaterThan'] = P['gt'] = function ( n, b ) {\n    id = 4;\n    return this['cmp']( n, b ) > 0;\n};\n\n\n/*\n * Return true if the value of this BigNumber is greater than or equal to\n * the value of BigNumber(n, b), otherwise returns false.\n */\nP['greaterThanOrEqualTo'] = P['gte'] = P['gt'] = function ( n, b ) {\n    id = 5;\n    return ( b = this['cmp']( n, b ) ) == 1 || b === 0;\n};\n\n\n/*\n * Return true if the value of this BigNumber is a finite number, otherwise\n * returns false.\n */\nP['isFinite'] = P['isF'] = function () {\n    return !!this['c'];\n};\n\n\n/*\n * Return true if the value of this BigNumber is NaN, otherwise returns\n * false.\n */\nP['isNaN'] = function () {\n    return !this['s'];\n};\n\n\n/*\n * Return true if the value of this BigNumber is negative, otherwise\n * returns false.\n */\nP['isNegative'] = P['isNeg'] = function () {\n    return this['s'] < 0;\n};\n\n\n/*\n * Return true if the value of this BigNumber is 0 or -0, otherwise returns\n * false.\n */\nP['isZero'] = P['isZ'] = function () {\n    return !!this['c'] && this['c'][0] == 0;\n};\n\n\n/*\n * Return true if the value of this BigNumber is less than the value of\n * BigNumber(n, b), otherwise returns false.\n */\nP['lessThan'] = P['lt'] = function ( n, b ) {\n    id = 6;\n    return this['cmp']( n, b ) < 0;\n};\n\n\n/*\n * Return true if the value of this BigNumber is less than or equal to the\n * value of BigNumber(n, b), otherwise returns false.\n */\nP['lessThanOrEqualTo'] = P['lte'] = P['le'] = function ( n, b ) {\n    id = 7;\n    return ( b = this['cmp']( n, b ) ) == -1 || b === 0;\n};\n\n\n/*\n *  n - 0 = n\n *  n - N = N\n *  n - I = -I\n *  0 - n = -n\n *  0 - 0 = 0\n *  0 - N = N\n *  0 - I = -I\n *  N - n = N\n *  N - 0 = N\n *  N - N = N\n *  N - I = N\n *  I - n = I\n *  I - 0 = I\n *  I - N = N\n *  I - I = N\n *\n * Return a new BigNumber whose value is the value of this BigNumber minus\n * the value of BigNumber(y, b).\n */\nP['minus'] = P['sub'] = function ( y, b ) {\n    var d, i, j, xLTy,\n        x = this,\n        a = x['s'];\n\n    b = ( id = 8, y = new BigNumber( y, b ) )['s'];\n\n    // Either NaN?\n    if ( !a || !b ) {\n        return new BigNumber(NaN);\n    }\n\n    // Signs differ?\n    if ( a != b ) {\n        return y['s'] = -b, x['plus'](y);\n    }\n\n    var xc = x['c'],\n        xe = x['e'],\n        yc = y['c'],\n        ye = y['e'];\n\n    if ( !xe || !ye ) {\n\n        // Either Infinity?\n        if ( !xc || !yc ) {\n            return xc ? ( y['s'] = -b, y ) : new BigNumber( yc ? x : NaN );\n        }\n\n        // Either zero?\n        if ( !xc[0] || !yc[0] ) {\n\n            // y is non-zero?\n            return yc[0]\n              ? ( y['s'] = -b, y )\n\n              // x is non-zero?\n              : new BigNumber( xc[0]\n                ? x\n\n                // Both are zero.\n                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                : ROUNDING_MODE == 3 ? -0 : 0 );\n        }\n    }\n\n    // Determine which is the bigger number.\n    // Prepend zeros to equalise exponents.\n    if ( xc = xc.slice(), a = xe - ye ) {\n        d = ( xLTy = a < 0 ) ? ( a = -a, xc ) : ( ye = xe, yc );\n\n        for ( d.reverse(), b = a; b--; d.push(0) ) {\n        }\n        d.reverse();\n    } else {\n\n        // Exponents equal. Check digit by digit.\n        j = ( ( xLTy = xc.length < yc.length ) ? xc : yc ).length;\n\n        for ( a = b = 0; b < j; b++ ) {\n\n            if ( xc[b] != yc[b] ) {\n                xLTy = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n\n    // x < y? Point xc to the array of the bigger number.\n    if ( xLTy ) {\n        d = xc, xc = yc, yc = d;\n        y['s'] = -y['s'];\n    }\n\n    /*\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter\n     * as subtraction only needs to start at yc.length.\n     */\n    if ( ( b = -( ( j = xc.length ) - yc.length ) ) > 0 ) {\n\n        for ( ; b--; xc[j++] = 0 ) {\n        }\n    }\n\n    // Subtract yc from xc.\n    for ( b = yc.length; b > a; ){\n\n        if ( xc[--b] < yc[b] ) {\n\n            for ( i = b; i && !xc[--i]; xc[i] = 9 ) {\n            }\n            --xc[i];\n            xc[b] += 10;\n        }\n        xc[b] -= yc[b];\n    }\n\n    // Remove trailing zeros.\n    for ( ; xc[--j] == 0; xc.pop() ) {\n    }\n\n    // Remove leading zeros and adjust exponent accordingly.\n    for ( ; xc[0] == 0; xc.shift(), --ye ) {\n    }\n\n    /*\n     * No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\n     * when neither x or y are Infinity.\n     */\n\n    // Underflow?\n    if ( ye < MIN_EXP || !xc[0] ) {\n\n        /*\n         * Following IEEE 754 (2008) 6.3,\n         * n - n = +0  but  n - n = -0 when rounding towards -Infinity.\n         */\n        if ( !xc[0] ) {\n            y['s'] = ROUNDING_MODE == 3 ? -1 : 1;\n        }\n\n        // Result is zero.\n        xc = [ye = 0];\n    }\n\n    return y['c'] = xc, y['e'] = ye, y;\n};\n\n\n/*\n *   n % 0 =  N\n *   n % N =  N\n *   0 % n =  0\n *  -0 % n = -0\n *   0 % 0 =  N\n *   0 % N =  N\n *   N % n =  N\n *   N % 0 =  N\n *   N % N =  N\n *\n * Return a new BigNumber whose value is the value of this BigNumber modulo\n * the value of BigNumber(y, b).\n */\nP['modulo'] = P['mod'] = function ( y, b ) {\n    var x = this,\n        xc = x['c'],\n        yc = ( id = 9, y = new BigNumber( y, b ) )['c'],\n        i = x['s'],\n        j = y['s'];\n\n    // Is x or y NaN, or y zero?\n    b = !i || !j || yc && !yc[0];\n\n    if ( b || xc && !xc[0] ) {\n        return new BigNumber( b ? NaN : x );\n    }\n\n    x['s'] = y['s'] = 1;\n    b = y['cmp'](x) == 1;\n    x['s'] = i, y['s'] = j;\n\n    return b\n      ? new BigNumber(x)\n      : ( i = DECIMAL_PLACES, j = ROUNDING_MODE,\n        DECIMAL_PLACES = 0, ROUNDING_MODE = 1,\n          x = x['div'](y),\n            DECIMAL_PLACES = i, ROUNDING_MODE = j,\n              this['minus']( x['times'](y) ) );\n};\n\n\n/*\n * Return a new BigNumber whose value is the value of this BigNumber\n * negated, i.e. multiplied by -1.\n */\nP['negated'] = P['neg'] = function () {\n    var x = new BigNumber(this);\n\n    return x['s'] = -x['s'] || null, x;\n};\n\n\n/*\n *  n + 0 = n\n *  n + N = N\n *  n + I = I\n *  0 + n = n\n *  0 + 0 = 0\n *  0 + N = N\n *  0 + I = I\n *  N + n = N\n *  N + 0 = N\n *  N + N = N\n *  N + I = N\n *  I + n = I\n *  I + 0 = I\n *  I + N = N\n *  I + I = I\n *\n * Return a new BigNumber whose value is the value of this BigNumber plus\n * the value of BigNumber(y, b).\n */\nP['plus'] = P['add'] = function ( y, b ) {\n    var d,\n        x = this,\n        a = x['s'];\n\n    b = ( id = 10, y = new BigNumber( y, b ) )['s'];\n\n    // Either NaN?\n    if ( !a || !b ) {\n        return new BigNumber(NaN);\n    }\n\n    // Signs differ?\n    if ( a != b ) {\n        return y['s'] = -b, x['minus'](y);\n    }\n\n    var xe = x['e'],\n        xc = x['c'],\n        ye = y['e'],\n        yc = y['c'];\n\n    if ( !xe || !ye ) {\n\n        // Either Infinity?\n        if ( !xc || !yc ) {\n\n            // Return +-Infinity.\n            return new BigNumber( a / 0 );\n        }\n\n        // Either zero?\n        if ( !xc[0] || !yc[0] ) {\n\n            // y is non-zero?\n            return yc[0]\n              ? y\n\n              // x is non-zero?\n              : new BigNumber( xc[0]\n                ? x\n\n                // Both are zero. Return zero.\n                : a * 0 );\n        }\n    }\n\n    // Prepend zeros to equalise exponents.\n    // Note: Faster to use reverse then do unshifts.\n    if ( xc = xc.slice(), a = xe - ye ) {\n        d = a > 0 ? ( ye = xe, yc ) : ( a = -a, xc );\n\n        for ( d.reverse(); a--; d.push(0) ) {\n        }\n        d.reverse();\n    }\n\n    // Point xc to the longer array.\n    if ( xc.length - yc.length < 0 ) {\n        d = yc, yc = xc, xc = d;\n    }\n\n    /*\n     * Only start adding at yc.length - 1 as the\n     * further digits of xc can be left as they are.\n     */\n    for ( a = yc.length, b = 0; a;\n         b = ( xc[--a] = xc[a] + yc[a] + b ) / 10 ^ 0, xc[a] %= 10 ) {\n    }\n\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n\n    if ( b ) {\n        xc.unshift(b);\n\n        // Overflow? (MAX_EXP + 1 possible)\n        if ( ++ye > MAX_EXP ) {\n\n            // Infinity.\n            xc = ye = null;\n        }\n    }\n\n     // Remove trailing zeros.\n    for ( a = xc.length; xc[--a] == 0; xc.pop() ) {\n    }\n\n    return y['c'] = xc, y['e'] = ye, y;\n};\n\n\n/*\n * Return a BigNumber whose value is the value of this BigNumber raised to\n * the power e. If e is negative round according to DECIMAL_PLACES and\n * ROUNDING_MODE.\n *\n * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n */\nP['toPower'] = P['pow'] = function ( e ) {\n\n    // e to integer, avoiding NaN or Infinity becoming 0.\n    var i = e * 0 == 0 ? e | 0 : e,\n        x = new BigNumber(this),\n        y = new BigNumber(ONE);\n\n    // Use Math.pow?\n    // Pass +-Infinity for out of range exponents.\n    if ( ( ( ( outOfRange = e < -MAX_POWER || e > MAX_POWER ) &&\n      (i = e * 1 / 0) ) ||\n\n         /*\n          * Any exponent that fails the parse becomes NaN.\n          *\n          * Include 'e !== 0' because on Opera -0 == parseFloat(-0) is false,\n          * despite -0 === parseFloat(-0) && -0 == parseFloat('-0') is true.\n          */\n         parse(e) != e && e !== 0 && !(i = NaN) ) &&\n\n          // 'pow() exponent not an integer: {e}'\n          // 'pow() exponent out of range: {e}'\n          !ifExceptionsThrow( e, 'exponent', 'pow' ) ||\n\n            // Pass zero to Math.pow, as any value to the power zero is 1.\n            !i ) {\n\n        // i is +-Infinity, NaN or 0.\n        return new BigNumber( Math.pow( x['toS'](), i ) );\n    }\n\n    for ( i = i < 0 ? -i : i; ; ) {\n\n        if ( i & 1 ) {\n            y = y['times'](x);\n        }\n        i >>= 1;\n\n        if ( !i ) {\n            break;\n        }\n        x = x['times'](x);\n    }\n\n    return e < 0 ? ONE['div'](y) : y;\n};\n\n\n/*\n * Return a BigNumber whose value is the value of this BigNumber raised to\n * the power m modulo n.\n *\n * m {BigNumber} the value to take the power of\n * n {BigNumber} the value to modulo by\n */\nP['powm'] = function ( m, n ) {\n    return this.pow(m).mod(n);\n};\n\n\n/*\n * Return a new BigNumber whose value is the value of this BigNumber\n * rounded to a maximum of dp decimal places using rounding mode rm, or to\n * 0 and ROUNDING_MODE respectively if omitted.\n *\n * [dp] {number} Integer, 0 to MAX inclusive.\n * [rm] {number} Integer, 0 to 8 inclusive.\n */\nP['round'] = function ( dp, rm ) {\n\n    dp = dp == null || ( ( ( outOfRange = dp < 0 || dp > MAX ) ||\n      parse(dp) != dp ) &&\n\n        // 'round() decimal places out of range: {dp}'\n        // 'round() decimal places not an integer: {dp}'\n        !ifExceptionsThrow( dp, 'decimal places', 'round' ) )\n          ? 0\n          : dp | 0;\n\n    rm = rm == null || ( ( ( outOfRange = rm < 0 || rm > 8 ) ||\n\n      // Include '&& rm !== 0' because with Opera -0 == parseFloat(-0) is false.\n      parse(rm) != rm && rm !== 0 ) &&\n\n        // 'round() mode not an integer: {rm}'\n        // 'round() mode out of range: {rm}'\n        !ifExceptionsThrow( rm, 'mode', 'round' ) )\n          ? ROUNDING_MODE\n          : rm | 0;\n\n    return setMode( this, dp, rm );\n};\n\n\n/*\n *  sqrt(-n) =  N\n *  sqrt( N) =  N\n *  sqrt(-I) =  N\n *  sqrt( I) =  I\n *  sqrt( 0) =  0\n *  sqrt(-0) = -0\n *\n * Return a new BigNumber whose value is the square root of the value of\n * this BigNumber, rounded according to DECIMAL_PLACES and ROUNDING_MODE.\n */\nP['squareRoot'] = P['sqrt'] = function () {\n    var n, r, re, t,\n        x = this,\n        c = x['c'],\n        s = x['s'],\n        e = x['e'],\n        dp = DECIMAL_PLACES,\n        rm = ROUNDING_MODE,\n        half = new BigNumber('0.5');\n\n    // Negative/NaN/Infinity/zero?\n    if ( s !== 1 || !c || !c[0] ) {\n\n        return new BigNumber( !s || s < 0 && ( !c || c[0] )\n          ? NaN\n          : c ? x : 1 / 0 );\n    }\n\n    // Initial estimate.\n    s = Math.sqrt( x['toS']() );\n    ROUNDING_MODE = 1;\n\n    /*\n      Math.sqrt underflow/overflow?\n      Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n     */\n    if ( s == 0 || s == 1 / 0 ) {\n        n = c.join('');\n\n        if ( !( n.length + e & 1 ) ) {\n            n += '0';\n        }\n        r = new BigNumber( Math.sqrt(n) + '' );\n\n        // r may still not be finite.\n        if ( !r['c'] ) {\n            r['c'] = [1];\n        }\n        r['e'] = ( ( ( e + 1 ) / 2 ) | 0 ) - ( e < 0 || e & 1 );\n    } else {\n        r = new BigNumber( n = s.toString() );\n    }\n    re = r['e'];\n    s = re + ( DECIMAL_PLACES += 4 );\n\n    if ( s < 3 ) {\n        s = 0;\n    }\n    e = s;\n\n    // Newton-Raphson iteration.\n    for ( ; ; ) {\n        t = r;\n        r = half['times']( t['plus']( x['div'](t) ) );\n\n        if ( t['c'].slice( 0, s ).join('') === r['c'].slice( 0, s ).join('') ) {\n            c = r['c'];\n\n            /*\n              The exponent of r may here be one less than the final result\n              exponent (re), e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust\n              s so the rounding digits are indexed correctly.\n             */\n            s = s - ( n && r['e'] < re );\n\n            /*\n              The 4th rounding digit may be in error by -1 so if the 4 rounding\n              digits are 9999 or 4999 (i.e. approaching a rounding boundary)\n              continue the iteration.\n             */\n            if ( c[s] == 9 && c[s - 1] == 9 && c[s - 2] == 9 &&\n                    ( c[s - 3] == 9 || n && c[s - 3] == 4 ) ) {\n\n                /*\n                  If 9999 on first run through, check to see if rounding up\n                  gives the exact result as the nines may infinitely repeat.\n                 */\n                if ( n && c[s - 3] == 9 ) {\n                    t = r['round']( dp, 0 );\n\n                    if ( t['times'](t)['eq'](x) ) {\n                        ROUNDING_MODE = rm;\n                        DECIMAL_PLACES = dp;\n\n                        return t;\n                    }\n                }\n                DECIMAL_PLACES += 4;\n                s += 4;\n                n = '';\n            } else {\n\n                /*\n                  If the rounding digits are null, 0000 or 5000, check for an\n                  exact result. If not, then there are further digits so\n                  increment the 1st rounding digit to ensure correct rounding.\n                 */\n                if ( !c[e] && !c[e - 1] && !c[e - 2] &&\n                        ( !c[e - 3] || c[e - 3] == 5 ) ) {\n\n                    // Truncate to the first rounding digit.\n                    if ( c.length > e - 2 ) {\n                        c.length = e - 2;\n                    }\n\n                    if ( !r['times'](r)['eq'](x) ) {\n\n                        while ( c.length < e - 3 ) {\n                            c.push(0);\n                        }\n                        c[e - 3]++;\n                    }\n                }\n                ROUNDING_MODE = rm;\n                rnd( r, DECIMAL_PLACES = dp, 10 );\n\n                return r;\n            }\n        }\n    }\n};\n\n\n/*\n *  n * 0 = 0\n *  n * N = N\n *  n * I = I\n *  0 * n = 0\n *  0 * 0 = 0\n *  0 * N = N\n *  0 * I = N\n *  N * n = N\n *  N * 0 = N\n *  N * N = N\n *  N * I = N\n *  I * n = I\n *  I * 0 = N\n *  I * N = N\n *  I * I = I\n *\n * Return a new BigNumber whose value is the value of this BigNumber times\n * the value of BigNumber(y, b).\n */\nP['times'] = P['mul'] = function ( y, b ) {\n    var c,\n        x = this,\n        xc = x['c'],\n        yc = ( id = 11, y = new BigNumber( y, b ) )['c'],\n        i = x['e'],\n        j = y['e'],\n        a = x['s'];\n\n    y['s'] = a == ( b = y['s'] ) ? 1 : -1;\n\n    // Either NaN/Infinity/0?\n    if ( !i && ( !xc || !xc[0] ) || !j && ( !yc || !yc[0] ) ) {\n\n        // Either NaN?\n        return new BigNumber( !a || !b ||\n\n          // x is 0 and y is Infinity  or  y is 0 and x is Infinity?\n          xc && !xc[0] && !yc || yc && !yc[0] && !xc\n\n            // Return NaN.\n            ? NaN\n\n            // Either Infinity?\n            : !xc || !yc\n\n              // Return +-Infinity.\n              ? y['s'] / 0\n\n              // x or y is 0. Return +-0.\n              : y['s'] * 0 );\n    }\n    y['e'] = i + j;\n\n    if ( ( a = xc.length ) < ( b = yc.length ) ) {\n        c = xc, xc = yc, yc = c, j = a, a = b, b = j;\n    }\n\n    for ( j = a + b, c = []; j--; c.push(0) ) {\n    }\n\n    // Multiply!\n    for ( i = b - 1; i > -1; i-- ) {\n\n        for ( b = 0, j = a + i;\n              j > i;\n              b = c[j] + yc[i] * xc[j - i - 1] + b,\n              c[j--] = b % 10 | 0,\n              b = b / 10 | 0 ) {\n        }\n\n        if ( b ) {\n            c[j] = ( c[j] + b ) % 10;\n        }\n    }\n\n    b && ++y['e'];\n\n    // Remove any leading zero.\n    !c[0] && c.shift();\n\n    // Remove trailing zeros.\n    for ( j = c.length; !c[--j]; c.pop() ) {\n    }\n\n    // No zero check needed as only x * 0 == 0 etc.\n\n    // Overflow?\n    y['c'] = y['e'] > MAX_EXP\n\n      // Infinity.\n      ? ( y['e'] = null )\n\n      // Underflow?\n      : y['e'] < MIN_EXP\n\n        // Zero.\n        ? [ y['e'] = 0 ]\n\n        // Neither.\n        : c;\n\n    return y;\n};\n\n/*\n * Return a buffer containing the \n */\nP['toBuffer'] = function ( opts ) {\n\n    if (typeof opts === 'string') {\n        if (opts !== 'mpint') return 'Unsupported Buffer representation';\n\n        var abs = this.abs();\n        var buf = abs.toBuffer({ size : 1, endian : 'big' });\n        var len = buf.length === 1 && buf[0] === 0 ? 0 : buf.length;\n        if (buf[0] & 0x80) len ++;\n\n        var ret = new Buffer(4 + len);\n        if (len > 0) buf.copy(ret, 4 + (buf[0] & 0x80 ? 1 : 0));\n        if (buf[0] & 0x80) ret[4] = 0;\n\n        ret[0] = len & (0xff << 24);\n        ret[1] = len & (0xff << 16);\n        ret[2] = len & (0xff << 8);\n        ret[3] = len & (0xff << 0);\n\n        // two's compliment for negative integers:\n        var isNeg = this.lt(0);\n        if (isNeg) {\n            for (var i = 4; i < ret.length; i++) {\n                ret[i] = 0xff - ret[i];\n            }\n        }\n        ret[4] = (ret[4] & 0x7f) | (isNeg ? 0x80 : 0);\n        if (isNeg) ret[ret.length - 1] ++;\n\n        return ret;\n    }\n\n    if (!opts) opts = {};\n\n    var endian = { 1 : 'big', '-1' : 'little' }[opts.endian]\n        || opts.endian || 'big'\n    ;\n\n    var hex = this.toString(16);\n    if (hex.charAt(0) === '-') throw new Error(\n        'converting negative numbers to Buffers not supported yet'\n    );\n\n    var size = opts.size === 'auto' ? Math.ceil(hex.length / 2) : (opts.size || 1);\n\n    var len = Math.ceil(hex.length / (2 * size)) * size;\n    var buf = new Buffer(len);\n\n    // zero-pad the hex string so the chunks are all `size` long\n    while (hex.length < 2 * len) hex = '0' + hex;\n\n    var hx = hex\n        .split(new RegExp('(.{' + (2 * size) + '})'))\n        .filter(function (s) { return s.length > 0 })\n    ;\n\n    hx.forEach(function (chunk, i) {\n        for (var j = 0; j < size; j++) {\n            var ix = i * size + (endian === 'big' ? j : size - j - 1);\n            buf[ix] = parseInt(chunk.slice(j*2,j*2+2), 16);\n        }\n    });\n\n    return buf;\n};\n\n/*\n * Return a string representing the value of this BigNumber in exponential\n * notation to dp fixed decimal places and rounded using ROUNDING_MODE if\n * necessary.\n *\n * [dp] {number} Integer, 0 to MAX inclusive.\n */\nP['toExponential'] = P['toE'] = function ( dp ) {\n\n    return format( this,\n      ( dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||\n\n        /*\n         * Include '&& dp !== 0' because with Opera -0 == parseFloat(-0) is\n         * false, despite -0 == parseFloat('-0') && 0 == -0 being true.\n         */\n        parse(dp) != dp && dp !== 0 ) &&\n\n          // 'toE() decimal places not an integer: {dp}'\n          // 'toE() decimal places out of range: {dp}'\n          !ifExceptionsThrow( dp, 'decimal places', 'toE' ) ) && this['c']\n            ? this['c'].length - 1\n            : dp | 0, 1 );\n};\n\n\n/*\n * Return a string representing the value of this BigNumber in normal\n * notation to dp fixed decimal places and rounded using ROUNDING_MODE if\n * necessary.\n *\n * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\n * but e.g. (-0.00001).toFixed(0) is '-0'.\n *\n * [dp] {number} Integer, 0 to MAX inclusive.\n */\nP['toFixed'] = P['toF'] = function ( dp ) {\n    var n, str, d,\n        x = this;\n\n    if ( !( dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||\n        parse(dp) != dp && dp !== 0 ) &&\n\n        // 'toF() decimal places not an integer: {dp}'\n        // 'toF() decimal places out of range: {dp}'\n        !ifExceptionsThrow( dp, 'decimal places', 'toF' ) ) ) {\n          d = x['e'] + ( dp | 0 );\n    }\n\n    n = TO_EXP_NEG, dp = TO_EXP_POS;\n    TO_EXP_NEG = -( TO_EXP_POS = 1 / 0 );\n\n    // Note: str is initially undefined.\n    if ( d == str ) {\n        str = x['toS']();\n    } else {\n        str = format( x, d );\n\n        // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.\n        // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n        if ( x['s'] < 0 && x['c'] ) {\n\n            // As e.g. -0 toFixed(3), will wrongly be returned as -0.000 from toString.\n            if ( !x['c'][0] ) {\n                str = str.replace(/^-/, '');\n\n            // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.\n            } else if ( str.indexOf('-') < 0 ) {\n                str = '-' + str;\n            }\n        }\n    }\n    TO_EXP_NEG = n, TO_EXP_POS = dp;\n\n    return str;\n};\n\n\n/*\n * Return a string array representing the value of this BigNumber as a\n * simple fraction with an integer numerator and an integer denominator.\n * The denominator will be a positive non-zero value less than or equal to\n * the specified maximum denominator. If a maximum denominator is not\n * specified, the denominator will be the lowest value necessary to\n * represent the number exactly.\n *\n * [maxD] {number|string|BigNumber} Integer >= 1 and < Infinity.\n */\nP['toFraction'] = P['toFr'] = function ( maxD ) {\n    var q, frac, n0, d0, d2, n, e,\n        n1 = d0 = new BigNumber(ONE),\n        d1 = n0 = new BigNumber('0'),\n        x = this,\n        xc = x['c'],\n        exp = MAX_EXP,\n        dp = DECIMAL_PLACES,\n        rm = ROUNDING_MODE,\n        d = new BigNumber(ONE);\n\n    // NaN, Infinity.\n    if ( !xc ) {\n        return x['toS']();\n    }\n\n    e = d['e'] = xc.length - x['e'] - 1;\n\n    // If max denominator is undefined or null...\n    if ( maxD == null ||\n\n         // or NaN...\n         ( !( id = 12, n = new BigNumber(maxD) )['s'] ||\n\n           // or less than 1, or Infinity...\n           ( outOfRange = n['cmp'](n1) < 0 || !n['c'] ) ||\n\n             // or not an integer...\n             ( ERRORS && n['e'] < n['c'].length - 1 ) ) &&\n\n               // 'toFr() max denominator not an integer: {maxD}'\n               // 'toFr() max denominator out of range: {maxD}'\n               !ifExceptionsThrow( maxD, 'max denominator', 'toFr' ) ||\n\n                 // or greater than the maxD needed to specify the value exactly...\n                 ( maxD = n )['cmp'](d) > 0 ) {\n\n        // d is e.g. 10, 100, 1000, 10000... , n1 is 1.\n        maxD = e > 0 ? d : n1;\n    }\n\n    MAX_EXP = 1 / 0;\n    n = new BigNumber( xc.join('') );\n\n    for ( DECIMAL_PLACES = 0, ROUNDING_MODE = 1; ; )  {\n        q = n['div'](d);\n        d2 = d0['plus']( q['times'](d1) );\n\n        if ( d2['cmp'](maxD) == 1 ) {\n            break;\n        }\n\n        d0 = d1, d1 = d2;\n\n        n1 = n0['plus']( q['times']( d2 = n1 ) );\n        n0 = d2;\n\n        d = n['minus']( q['times']( d2 = d ) );\n        n = d2;\n    }\n\n    d2 = maxD['minus'](d0)['div'](d1);\n    n0 = n0['plus']( d2['times'](n1) );\n    d0 = d0['plus']( d2['times'](d1) );\n\n    n0['s'] = n1['s'] = x['s'];\n\n    DECIMAL_PLACES = e * 2;\n    ROUNDING_MODE = rm;\n\n    // Determine which fraction is closer to x, n0 / d0 or n1 / d1?\n    frac = n1['div'](d1)['minus'](x)['abs']()['cmp'](\n      n0['div'](d0)['minus'](x)['abs']() ) < 1\n      ? [ n1['toS'](), d1['toS']() ]\n      : [ n0['toS'](), d0['toS']() ];\n\n    return MAX_EXP = exp, DECIMAL_PLACES = dp, frac;\n};\n\n\n/*\n * Return a string representing the value of this BigNumber to sd significant\n * digits and rounded using ROUNDING_MODE if necessary.\n * If sd is less than the number of digits necessary to represent the integer\n * part of the value in normal notation, then use exponential notation.\n *\n * sd {number} Integer, 1 to MAX inclusive.\n */\nP['toPrecision'] = P['toP'] = function ( sd ) {\n\n    /*\n     * ERRORS true: Throw if sd not undefined, null or an integer in range.\n     * ERRORS false: Ignore sd if not a number or not in range.\n     * Truncate non-integers.\n     */\n    return sd == null || ( ( ( outOfRange = sd < 1 || sd > MAX ) ||\n      parse(sd) != sd ) &&\n\n        // 'toP() precision not an integer: {sd}'\n        // 'toP() precision out of range: {sd}'\n        !ifExceptionsThrow( sd, 'precision', 'toP' ) )\n          ? this['toS']()\n          : format( this, --sd | 0, 2 );\n};\n\n\n/*\n * Return a string representing the value of this BigNumber in base b, or\n * base 10 if b is omitted. If a base is specified, including base 10,\n * round according to DECIMAL_PLACES and ROUNDING_MODE.\n * If a base is not specified, and this BigNumber has a positive exponent\n * that is equal to or greater than TO_EXP_POS, or a negative exponent equal\n * to or less than TO_EXP_NEG, return exponential notation.\n *\n * [b] {number} Integer, 2 to 64 inclusive.\n */\nP['toString'] = P['toS'] = function ( b ) {\n    var u, str, strL,\n        x = this,\n        xe = x['e'];\n\n    // Infinity or NaN?\n    if ( xe === null ) {\n        str = x['s'] ? 'Infinity' : 'NaN';\n\n    // Exponential format?\n    } else if ( b === u && ( xe <= TO_EXP_NEG || xe >= TO_EXP_POS ) ) {\n        return format( x, x['c'].length - 1, 1 );\n    } else {\n        str = x['c'].join('');\n\n        // Negative exponent?\n        if ( xe < 0 ) {\n\n            // Prepend zeros.\n            for ( ; ++xe; str = '0' + str ) {\n            }\n            str = '0.' + str;\n\n        // Positive exponent?\n        } else if ( strL = str.length, xe > 0 ) {\n\n            if ( ++xe > strL ) {\n\n                // Append zeros.\n                for ( xe -= strL; xe-- ; str += '0' ) {\n                }\n            } else if ( xe < strL ) {\n                str = str.slice( 0, xe ) + '.' + str.slice(xe);\n            }\n\n        // Exponent zero.\n        } else {\n            if ( u = str.charAt(0), strL > 1 ) {\n                str = u + '.' + str.slice(1);\n\n            // Avoid '-0'\n            } else if ( u == '0' ) {\n                return u;\n            }\n        }\n\n        if ( b != null ) {\n\n            if ( !( outOfRange = !( b >= 2 && b < 65 ) ) &&\n              ( b == (b | 0) || !ERRORS ) ) {\n                str = convert( str, b | 0, 10, x['s'] );\n\n                // Avoid '-0'\n                if ( str == '0' ) {\n                    return str;\n                }\n            } else {\n\n                // 'toS() base not an integer: {b}'\n                // 'toS() base out of range: {b}'\n                ifExceptionsThrow( b, 'base', 'toS' );\n            }\n        }\n\n    }\n\n    return x['s'] < 0 ? '-' + str : str;\n};\n\n\n/*\n * Return as toString, but do not accept a base argument.\n */\nP['valueOf'] = function () {\n    return this['toS']();\n};\n\n\n// Add aliases for BigDecimal methods.\n//P['add'] = P['plus'];\n//P['subtract'] = P['minus'];\n//P['multiply'] = P['times'];\n//P['divide'] = P['div'];\n//P['remainder'] = P['mod'];\n//P['compareTo'] = P['cmp'];\n//P['negate'] = P['neg'];\n\n\n// EXPORT\nmodule.exports = BigNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1iaWdudW0vYmlnbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNDQUFzQztBQUN2Rjs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0IsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0dBQWtHLEVBQUU7QUFDcEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCLG9EQUFvRCxHQUFHLFNBQVMsRUFBRTtBQUNsRTtBQUNBO0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBOztBQUVBLGtEQUFrRCxHQUFHO0FBQ3JELG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxHQUFHO0FBQzdDLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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QUNBOztBQUVBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsZ0RBQWdELEVBQUU7QUFDbEQsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1YnN0cmVhbWluZy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWJpZ251bS9iaWdudW1iZXIuanM/ODExNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBiaWdudW1iZXIuanMgdjEuMy4wIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qcy9MSUNFTkNFICovXG5cbi8qanNsaW50IGJpdHdpc2U6IHRydWUsIGVxZXE6IHRydWUsIHBsdXNwbHVzOiB0cnVlLCBzdWI6IHRydWUsIHdoaXRlOiB0cnVlLCBtYXhlcnI6IDUwMCAqL1xuLypnbG9iYWwgbW9kdWxlICovXG5cbi8qXG4gIGJpZ251bWJlci5qcyB2MS4zLjBcbiAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cbiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXG4gIENvcHlyaWdodCAoYykgMjAxMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxuICBNSVQgRXhwYXQgTGljZW5jZVxuKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIERFRkFVTFRTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLypcbiAqIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgc3RhdGVkIHJhbmdlcyAoaW5jbHVzaXZlKS5cbiAqIE1vc3Qgb2YgdGhlc2UgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkIGR1cmluZyBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuY29uZmlnKCkuXG4gKi9cblxuLypcbiAqIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsXG4gKiBNQVhfRVhQLCBhbmQgdGhlIGFyZ3VtZW50IHRvIHRvRml4ZWQsIHRvUHJlY2lzaW9uIGFuZCB0b0V4cG9uZW50aWFsLCBiZXlvbmRcbiAqIHdoaWNoIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gKGlmIEVSUk9SUyBpcyB0cnVlKS5cbiAqL1xudmFyIE1BWCA9IDFFOSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gMWUrOVxuXG4gICAgLy8gTGltaXQgb2YgbWFnbml0dWRlIG9mIGV4cG9uZW50IGFyZ3VtZW50IHRvIHRvUG93ZXIuXG4gICAgTUFYX1BPV0VSID0gMUU2LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byAxZSs2XG5cbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxuICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXG5cbiAgICAvKlxuICAgICAqIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuXG4gICAgICogdXNpbmcgdG9GaXhlZCwgdG9QcmVjaXNpb24gYW5kIHRvRXhwb25lbnRpYWwsIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXG4gICAgICogVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxuICAgICAqIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXG4gICAgICogQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxuICAgICAqIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cbiAgICAgKiBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxuICAgICAqIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cbiAgICAgKiBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXG4gICAgICogSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cbiAgICAgKiBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxuICAgICAqL1xuICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxuXG4gICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXG5cbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAvLyBOdW1iZXIgdHlwZTogLTdcbiAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcblxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAvLyBOdW1iZXIgdHlwZTogMjFcbiAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxuXG4gICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cblxuICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cbiAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcbiAgICBNSU5fRVhQID0gLU1BWCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXG5cbiAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxuICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXG4gICAgTUFYX0VYUCA9IE1BWCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcblxuICAgIC8vIFdoZXRoZXIgQmlnTnVtYmVyIEVycm9ycyBhcmUgZXZlciB0aHJvd24uXG4gICAgLy8gQ0hBTkdFIHBhcnNlSW50IHRvIHBhcnNlRmxvYXQgaWYgY2hhbmdpbmcgRVJST1JTIHRvIGZhbHNlLlxuICAgIEVSUk9SUyA9IHRydWUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcbiAgICBwYXJzZSA9IHBhcnNlSW50LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZUludCBvciBwYXJzZUZsb2F0XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlLFxuICAgIERJR0lUUyA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJyxcbiAgICBvdXRPZlJhbmdlLFxuICAgIGlkID0gMCxcbiAgICBpc1ZhbGlkID0gL14tPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2ksXG4gICAgdHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSB8fCBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpfSxcbiAgICBPTkUgPSBCaWdOdW1iZXIoMSk7XG5cblxuLy8gQ09OU1RSVUNUT1JcblxuXG4vKlxuICogVGhlIGV4cG9ydGVkIGZ1bmN0aW9uLlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxuICpcbiAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXG4gKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygbi4gSW50ZWdlciwgMiB0byA2NCBpbmNsdXNpdmUuXG4gKi9cbmZ1bmN0aW9uIEJpZ051bWJlciggbiwgYiApIHtcbiAgICB2YXIgZSwgaSwgaXNOdW0sIGRpZ2l0cywgdmFsaWQsIG9yaWcsXG4gICAgICAgIHggPSB0aGlzO1xuXG4gICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIHVzYWdlIHdpdGhvdXQgbmV3LlxuICAgIGlmICggISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIG4sIGIgKVxuICAgIH1cblxuICAgIC8vIER1cGxpY2F0ZS5cbiAgICBpZiAoIG4gaW5zdGFuY2VvZiBCaWdOdW1iZXIgKSB7XG4gICAgICAgIGlkID0gMDtcblxuICAgICAgICAvLyBlIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKCBiICE9PSBlICkge1xuICAgICAgICAgICAgbiArPSAnJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeFsncyddID0gblsncyddO1xuICAgICAgICAgICAgeFsnZSddID0gblsnZSddO1xuICAgICAgICAgICAgeFsnYyddID0gKCBuID0gblsnYyddICkgPyBuLnNsaWNlKCkgOiBuO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbnVtYmVyLCBjaGVjayBpZiBtaW51cyB6ZXJvLlxuICAgIGlmICggdHlwZW9mIG4gIT0gJ3N0cmluZycgKSB7XG4gICAgICAgIG4gPSAoIGlzTnVtID0gdHlwZW9mIG4gPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuKSA9PSAnW29iamVjdCBOdW1iZXJdJyApICYmXG4gICAgICAgICAgICAgICAgbiA9PT0gMCAmJiAxIC8gbiA8IDAgPyAnLTAnIDogbiArICcnO1xuICAgIH1cblxuICAgIG9yaWcgPSBuO1xuXG4gICAgaWYgKCBiID09PSBlICYmIGlzVmFsaWQudGVzdChuKSApIHtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi5cbiAgICAgICAgeFsncyddID0gbi5jaGFyQXQoMCkgPT0gJy0nID8gKCBuID0gbi5zbGljZSgxKSwgLTEgKSA6IDE7XG5cbiAgICAvLyBFaXRoZXIgbiBpcyBub3QgYSB2YWxpZCBCaWdOdW1iZXIgb3IgYSBiYXNlIGhhcyBiZWVuIHNwZWNpZmllZC5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEVuYWJsZSBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudC5cbiAgICAgICAgLy8gRW5zdXJlIHJldHVybiB2YWx1ZSBpcyByb3VuZGVkIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXG4gICAgICAgIGlmICggYiA9PSAxMCApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHNldE1vZGUoIG4sIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFICk7XG4gICAgICAgIH1cblxuICAgICAgICBuID0gdHJpbS5jYWxsKG4pLnJlcGxhY2UoIC9eXFwrKD8hLSkvLCAnJyApO1xuXG4gICAgICAgIHhbJ3MnXSA9IG4uY2hhckF0KDApID09ICctJyA/ICggbiA9IG4ucmVwbGFjZSggL14tKD8hLSkvLCAnJyApLCAtMSApIDogMTtcblxuICAgICAgICBpZiAoIGIgIT0gbnVsbCApIHtcblxuICAgICAgICAgICAgaWYgKCAoIGIgPT0gKGIgfCAwKSB8fCAhRVJST1JTICkgJiZcbiAgICAgICAgICAgICAgISggb3V0T2ZSYW5nZSA9ICEoIGIgPj0gMiAmJiBiIDwgNjUgKSApICkge1xuXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJ1snICsgRElHSVRTLnNsaWNlKCAwLCBiID0gYiB8IDAgKSArICddKyc7XG5cbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgbm9uLWRlY2ltYWwgbnVtYmVyIHZhbGlkaXR5IHRlc3QgYW5kIGJhc2UgY29udmVyc2lvblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgYC5gIGZyb20gZS5nLiAnMS4nLCBhbmQgcmVwbGFjZSBlLmcuICcuMScgd2l0aCAnMC4xJy5cbiAgICAgICAgICAgICAgICBuID0gbi5yZXBsYWNlKCAvXFwuJC8sICcnICkucmVwbGFjZSggL15cXC4vLCAnMC4nICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbnkgbnVtYmVyIGluIGV4cG9uZW50aWFsIGZvcm0gd2lsbCBmYWlsIGR1ZSB0byB0aGUgZSsvLS5cbiAgICAgICAgICAgICAgICBpZiAoIHZhbGlkID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICdeJyArIGRpZ2l0cyArICcoPzpcXFxcLicgKyBkaWdpdHMgKyAnKT8kJywgYiA8IDM3ID8gJ2knIDogJycgKS50ZXN0KG4pICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNOdW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbi5yZXBsYWNlKCAvXjBcXC4wKnxcXC4vLCAnJyApLmxlbmd0aCA+IDE1ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBvcmlnLCAwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSAhaXNOdW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IGNvbnZlcnQoIG4sIDEwLCBiLCB4WydzJ10gKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG4gIT0gJ0luZmluaXR5JyAmJiBuICE9ICdOYU4nICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXG4gICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBvcmlnLCAxLCBiICk7XG4gICAgICAgICAgICAgICAgICAgIG4gPSAnTmFOJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBiYXNlIG5vdCBhbiBpbnRlZ2VyOiB7Yn0nXG4gICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xuICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBiLCAyICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYmFzZS5cbiAgICAgICAgICAgICAgICB2YWxpZCA9IGlzVmFsaWQudGVzdChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkID0gaXNWYWxpZC50ZXN0KG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhdmFsaWQgKSB7XG5cbiAgICAgICAgICAgIC8vIEluZmluaXR5L05hTlxuICAgICAgICAgICAgeFsnYyddID0geFsnZSddID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTmFOXG4gICAgICAgICAgICBpZiAoIG4gIT0gJ0luZmluaXR5JyApIHtcblxuICAgICAgICAgICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiBOYU4uXG4gICAgICAgICAgICAgICAgaWYgKCBuICE9ICdOYU4nICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbm90IGEgbnVtYmVyOiB7bn0nXG4gICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBvcmlnLCAzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhbJ3MnXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlY2ltYWwgcG9pbnQ/XG4gICAgaWYgKCAoIGUgPSBuLmluZGV4T2YoJy4nKSApID4gLTEgKSB7XG4gICAgICAgIG4gPSBuLnJlcGxhY2UoICcuJywgJycgKTtcbiAgICB9XG5cbiAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xuICAgIGlmICggKCBpID0gbi5zZWFyY2goIC9lL2kgKSApID4gMCApIHtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXG4gICAgICAgIGlmICggZSA8IDAgKSB7XG4gICAgICAgICAgICBlID0gaTtcbiAgICAgICAgfVxuICAgICAgICBlICs9ICtuLnNsaWNlKCBpICsgMSApO1xuICAgICAgICBuID0gbi5zdWJzdHJpbmcoIDAsIGkgKTtcblxuICAgIH0gZWxzZSBpZiAoIGUgPCAwICkge1xuXG4gICAgICAgIC8vIEludGVnZXIuXG4gICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cbiAgICBmb3IgKCBpID0gMDsgbi5jaGFyQXQoaSkgPT0gJzAnOyBpKysgKSB7XG4gICAgfVxuXG4gICAgYiA9IG4ubGVuZ3RoO1xuXG4gICAgLy8gRGlzYWxsb3cgbnVtYmVycyB3aXRoIG92ZXIgMTUgc2lnbmlmaWNhbnQgZGlnaXRzIGlmIG51bWJlciB0eXBlLlxuICAgIGlmICggaXNOdW0gJiYgYiA+IDE1ICYmIG4uc2xpY2UoaSkubGVuZ3RoID4gMTUgKSB7XG5cbiAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xuICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggb3JpZywgMCApO1xuICAgIH1cbiAgICBpZCA9IDA7XG5cbiAgICAvLyBPdmVyZmxvdz9cbiAgICBpZiAoICggZSAtPSBpICsgMSApID4gTUFYX0VYUCApIHtcblxuICAgICAgICAvLyBJbmZpbml0eS5cbiAgICAgICAgeFsnYyddID0geFsnZSddID0gbnVsbDtcblxuICAgIC8vIFplcm8gb3IgdW5kZXJmbG93P1xuICAgIH0gZWxzZSBpZiAoIGkgPT0gYiB8fCBlIDwgTUlOX0VYUCApIHtcblxuICAgICAgICAvLyBaZXJvLlxuICAgICAgICB4WydjJ10gPSBbIHhbJ2UnXSA9IDAgXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgZm9yICggOyBuLmNoYXJBdCgtLWIpID09ICcwJzsgKSB7XG4gICAgICAgIH1cblxuICAgICAgICB4WydlJ10gPSBlO1xuICAgICAgICB4WydjJ10gPSBbXTtcblxuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgKHdpdGhvdXQgbGVhZGluZyBhbmQgdHJhaWxpbmcgemVyb3MpLlxuICAgICAgICBmb3IgKCBlID0gMDsgaSA8PSBiOyB4WydjJ11bZSsrXSA9ICtuLmNoYXJBdChpKyspICkge1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVMvTUVUSE9EU1xuXG5cbkJpZ051bWJlclsnUk9VTkRfVVAnXSA9IDA7XG5CaWdOdW1iZXJbJ1JPVU5EX0RPV04nXSA9IDE7XG5CaWdOdW1iZXJbJ1JPVU5EX0NFSUwnXSA9IDI7XG5CaWdOdW1iZXJbJ1JPVU5EX0ZMT09SJ10gPSAzO1xuQmlnTnVtYmVyWydST1VORF9IQUxGX1VQJ10gPSA0O1xuQmlnTnVtYmVyWydST1VORF9IQUxGX0RPV04nXSA9IDU7XG5CaWdOdW1iZXJbJ1JPVU5EX0hBTEZfRVZFTiddID0gNjtcbkJpZ051bWJlclsnUk9VTkRfSEFMRl9DRUlMJ10gPSA3O1xuQmlnTnVtYmVyWydST1VORF9IQUxGX0ZMT09SJ10gPSA4O1xuXG4vKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIGZyb20gYSBCdWZmZXJcbiAqL1xuQmlnTnVtYmVyWydmcm9tQnVmZmVyJ10gPSBmdW5jdGlvbiAoYnVmLCBvcHRzKSB7XG5cbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcblxuICAgIHZhciBlbmRpYW4gPSB7IDEgOiAnYmlnJywgJy0xJyA6ICdsaXR0bGUnIH1bb3B0cy5lbmRpYW5dXG4gICAgICAgIHx8IG9wdHMuZW5kaWFuIHx8ICdiaWcnXG4gICAgO1xuXG4gICAgdmFyIHNpemUgPSBvcHRzLnNpemUgPT09ICdhdXRvJyA/IE1hdGguY2VpbChidWYubGVuZ3RoKSA6IChvcHRzLnNpemUgfHwgMSk7XG5cbiAgICBpZiAoYnVmLmxlbmd0aCAlIHNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBsZW5ndGggKCcgKyBidWYubGVuZ3RoICsgJyknXG4gICAgICAgICAgICArICcgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHNpemUgKCcgKyBzaXplICsgJyknXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGhleCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBzaXplKSB7XG4gICAgICAgIHZhciBjaHVuayA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemU7IGorKykge1xuICAgICAgICAgICAgY2h1bmsucHVzaChidWZbXG4gICAgICAgICAgICAgICAgaSArIChlbmRpYW4gPT09ICdiaWcnID8gaiA6IChzaXplIC0gaiAtIDEpKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBoZXgucHVzaChjaHVua1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYyA8IDE2ID8gJzAnIDogJycpICsgYy50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJpZ051bWJlcihoZXguam9pbignJyksIDE2KTtcblxufTtcblxuLypcbiAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxuICpcbiAqIEFjY2VwdCBhbiBvYmplY3Qgb3IgYW4gYXJndW1lbnQgbGlzdCwgd2l0aCBvbmUgb3IgbWFueSBvZiB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzIG9yIHBhcmFtZXRlcnMgcmVzcGVjdGl2ZWx5OlxuICogWyBERUNJTUFMX1BMQUNFUyBbLCBST1VORElOR19NT0RFIFssIEVYUE9ORU5USUFMX0FUIFssIFJBTkdFIFssIEVSUk9SUyBdXV1dXVxuICpcbiAqIEUuZy5cbiAqIEJpZ051bWJlci5jb25maWcoMjAsIDQpIGlzIGVxdWl2YWxlbnQgdG9cbiAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxuICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQuXG4gKlxuICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxuICovXG5CaWdOdW1iZXJbJ2NvbmZpZyddID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2LCBwLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgciA9IHt9LFxuICAgICAgICBhID0gYXJndW1lbnRzLFxuICAgICAgICBvID0gYVswXSxcbiAgICAgICAgYyA9ICdjb25maWcnLFxuICAgICAgICBpblJhbmdlID0gZnVuY3Rpb24gKCBuLCBsbywgaGkgKSB7XG4gICAgICAgICAgcmV0dXJuICEoICggb3V0T2ZSYW5nZSA9IG4gPCBsbyB8fCBuID4gaGkgKSB8fFxuICAgICAgICAgICAgcGFyc2UobikgIT0gbiAmJiBuICE9PSAwICk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyA9IG8gJiYgdHlwZW9mIG8gPT0gJ29iamVjdCdcbiAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtpZiAoIG8uaGFzT3duUHJvcGVydHkocCkgKSByZXR1cm4gKCB2ID0gb1twXSApICE9IG51bGx9XG4gICAgICAgICAgOiBmdW5jdGlvbiAoKSB7aWYgKCBhLmxlbmd0aCA+IGkgKSByZXR1cm4gKCB2ID0gYVtpKytdICkgIT0gbnVsbH07XG5cbiAgICAvLyBbREVDSU1BTF9QTEFDRVNdIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICBpZiAoIGhhcyggcCA9ICdERUNJTUFMX1BMQUNFUycgKSApIHtcblxuICAgICAgICBpZiAoIGluUmFuZ2UoIHYsIDAsIE1BWCApICkge1xuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2IHwgMDtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIERFQ0lNQUxfUExBQ0VTIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgREVDSU1BTF9QTEFDRVMgb3V0IG9mIHJhbmdlOiB7dn0nXG4gICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggdiwgcCwgYyApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJbcF0gPSBERUNJTUFMX1BMQUNFUztcblxuICAgIC8vIFtST1VORElOR19NT0RFXSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxuICAgIGlmICggaGFzKCBwID0gJ1JPVU5ESU5HX01PREUnICkgKSB7XG5cbiAgICAgICAgaWYgKCBpblJhbmdlKCB2LCAwLCA4ICkgKSB7XG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdiB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vICdjb25maWcoKSBST1VORElOR19NT0RFIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUk9VTkRJTkdfTU9ERSBvdXQgb2YgcmFuZ2U6IHt2fSdcbiAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCB2LCBwLCBjICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcltwXSA9IFJPVU5ESU5HX01PREU7XG5cbiAgICAvKlxuICAgICAqIFtFWFBPTkVOVElBTF9BVF0ge251bWJlcnxudW1iZXJbXX0gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXG4gICAgICogWyBpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZSBdLlxuICAgICAqL1xuICAgIGlmICggaGFzKCBwID0gJ0VYUE9ORU5USUFMX0FUJyApICkge1xuXG4gICAgICAgIGlmICggaW5SYW5nZSggdiwgLU1BWCwgTUFYICkgKSB7XG4gICAgICAgICAgICBUT19FWFBfTkVHID0gLSggVE9fRVhQX1BPUyA9IH5+KCB2IDwgMCA/IC12IDogK3YgKSApO1xuICAgICAgICB9IGVsc2UgaWYgKCAhb3V0T2ZSYW5nZSAmJiB2ICYmIGluUmFuZ2UoIHZbMF0sIC1NQVgsIDAgKSAmJlxuICAgICAgICAgIGluUmFuZ2UoIHZbMV0sIDAsIE1BWCApICkge1xuICAgICAgICAgICAgVE9fRVhQX05FRyA9IH5+dlswXTtcbiAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB+fnZbMV07XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vICdjb25maWcoKSBFWFBPTkVOVElBTF9BVCBub3QgYW4gaW50ZWdlciBvciBub3QgW2ludGVnZXIsIGludGVnZXJdOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVhQT05FTlRJQUxfQVQgb3V0IG9mIHJhbmdlIG9yIG5vdCBbbmVnYXRpdmUsIHBvc2l0aXZlOiB7dn0nXG4gICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggdiwgcCwgYywgMSApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJbcF0gPSBbIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MgXTtcblxuICAgIC8qXG4gICAgICogW1JBTkdFXVsge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXG4gICAgICogWyBpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZSBdLlxuICAgICAqL1xuICAgIGlmICggaGFzKCBwID0gJ1JBTkdFJyApICkge1xuXG4gICAgICAgIGlmICggaW5SYW5nZSggdiwgLU1BWCwgTUFYICkgJiYgfn52ICkge1xuICAgICAgICAgICAgTUlOX0VYUCA9IC0oIE1BWF9FWFAgPSB+figgdiA8IDAgPyAtdiA6ICt2ICkgKTtcbiAgICAgICAgfSBlbHNlIGlmICggIW91dE9mUmFuZ2UgJiYgdiAmJiBpblJhbmdlKCB2WzBdLCAtTUFYLCAtMSApICYmXG4gICAgICAgICAgaW5SYW5nZSggdlsxXSwgMSwgTUFYICkgKSB7XG4gICAgICAgICAgICBNSU5fRVhQID0gfn52WzBdLCBNQVhfRVhQID0gfn52WzFdO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0Ugbm90IGEgbm9uLXplcm8gaW50ZWdlciBvciBub3QgW2ludGVnZXIsIGludGVnZXJdOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0Ugb3V0IG9mIHJhbmdlIG9yIG5vdCBbbmVnYXRpdmUsIHBvc2l0aXZlOiB7dn0nXG4gICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggdiwgcCwgYywgMSwgMSApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJbcF0gPSBbIE1JTl9FWFAsIE1BWF9FWFAgXTtcblxuICAgIC8vIFtFUlJPUlNdIHtib29sZWFufG51bWJlcn0gdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cbiAgICBpZiAoIGhhcyggcCA9ICdFUlJPUlMnICkgKSB7XG5cbiAgICAgICAgaWYgKCB2ID09PSAhIXYgfHwgdiA9PT0gMSB8fCB2ID09PSAwICkge1xuICAgICAgICAgICAgcGFyc2UgPSAoIG91dE9mUmFuZ2UgPSBpZCA9IDAsIEVSUk9SUyA9ICEhdiApXG4gICAgICAgICAgICAgID8gcGFyc2VJbnRcbiAgICAgICAgICAgICAgOiBwYXJzZUZsb2F0O1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVJST1JTIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7dn0nXG4gICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggdiwgcCwgYywgMCwgMCwgMSApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJbcF0gPSBFUlJPUlM7XG5cbiAgICByZXR1cm4gcjtcbn07XG5cblxuLy8gUFJJVkFURSBGVU5DVElPTlNcblxuXG4vLyBBc3NlbWJsZSBlcnJvciBtZXNzYWdlcy4gVGhyb3cgQmlnTnVtYmVyIEVycm9ycy5cbmZ1bmN0aW9uIGlmRXhjZXB0aW9uc1Rocm93KCBhcmcsIGksIGosIGlzQXJyYXksIGlzUmFuZ2UsIGlzRXJyb3JzKSB7XG5cbiAgICBpZiAoIEVSUk9SUyApIHtcbiAgICAgICAgdmFyIGVycm9yLFxuICAgICAgICAgICAgbWV0aG9kID0gWyduZXcgQmlnTnVtYmVyJywgJ2NtcCcsICdkaXYnLCAnZXEnLCAnZ3QnLCAnZ3RlJywgJ2x0JyxcbiAgICAgICAgICAgICAgICAgJ2x0ZScsICdtaW51cycsICdtb2QnLCAncGx1cycsICd0aW1lcycsICd0b0ZyJ1xuICAgICAgICAgICAgICAgIF1bIGlkID8gaWQgPCAwID8gLWlkIDogaWQgOiAxIC8gaWQgPCAwID8gMSA6IDAgXSArICcoKScsXG4gICAgICAgICAgICBtZXNzYWdlID0gb3V0T2ZSYW5nZSA/ICcgb3V0IG9mIHJhbmdlJyA6ICcgbm90IGEnICtcbiAgICAgICAgICAgICAgKCBpc1JhbmdlID8gJyBub24temVybycgOiAnbicgKSArICcgaW50ZWdlcic7XG5cbiAgICAgICAgbWVzc2FnZSA9ICggW1xuICAgICAgICAgICAgbWV0aG9kICsgJyBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0cycsXG4gICAgICAgICAgICBtZXRob2QgKyAnIG5vdCBhIGJhc2UgJyArIGogKyAnIG51bWJlcicsXG4gICAgICAgICAgICBtZXRob2QgKyAnIGJhc2UnICsgbWVzc2FnZSxcbiAgICAgICAgICAgIG1ldGhvZCArICcgbm90IGEgbnVtYmVyJyBdW2ldIHx8XG4gICAgICAgICAgICAgIGogKyAnKCkgJyArIGkgKyAoIGlzRXJyb3JzXG4gICAgICAgICAgICAgICAgPyAnIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0J1xuICAgICAgICAgICAgICAgIDogbWVzc2FnZSArICggaXNBcnJheVxuICAgICAgICAgICAgICAgICAgPyAnIG9yIG5vdCBbJyArICggb3V0T2ZSYW5nZVxuICAgICAgICAgICAgICAgICAgICA/ICcgbmVnYXRpdmUsIHBvc2l0aXZlJ1xuICAgICAgICAgICAgICAgICAgICA6ICcgaW50ZWdlciwgaW50ZWdlcicgKSArICcgXSdcbiAgICAgICAgICAgICAgICAgIDogJycgKSApICkgKyAnOiAnICsgYXJnO1xuXG4gICAgICAgIG91dE9mUmFuZ2UgPSBpZCA9IDA7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvclsnbmFtZSddID0gJ0JpZ051bWJlciBFcnJvcic7XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cbiAqL1xuZnVuY3Rpb24gY29udmVydCggblN0ciwgYmFzZU91dCwgYmFzZUluLCBzaWduICkge1xuICAgIHZhciBlLCBkdnMsIGR2ZCwgbkFyciwgZnJhY0FyciwgZnJhY0JOO1xuXG4gICAgLy8gQ29udmVydCBzdHJpbmcgb2YgYmFzZSBiSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxuICAgIC8vIEVnLiBzdHJUb0FycignMjU1JywgMTApIHdoZXJlIGJhc2VPdXQgaXMgMTYsIHJldHVybnMgWzE1LCAxNV0uXG4gICAgLy8gRWcuIHN0clRvQXJyKCdmZicsIDE2KSAgd2hlcmUgYmFzZU91dCBpcyAxMCwgcmV0dXJucyBbMiwgNSwgNV0uXG4gICAgZnVuY3Rpb24gc3RyVG9BcnIoIHN0ciwgYkluICkge1xuICAgICAgICB2YXIgaixcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgc3RyTCA9IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICBhcnJMLFxuICAgICAgICAgICAgYXJyID0gWzBdO1xuXG4gICAgICAgIGZvciAoIGJJbiA9IGJJbiB8fCBiYXNlSW47IGkgPCBzdHJMOyBpKysgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIGFyckwgPSBhcnIubGVuZ3RoLCBqID0gMDsgaiA8IGFyckw7IGFycltqXSAqPSBiSW4sIGorKyApIHtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggYXJyWzBdICs9IERJR0lUUy5pbmRleE9mKCBzdHIuY2hhckF0KGkpICksIGogPSAwO1xuICAgICAgICAgICAgICAgICAgaiA8IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGFycltqXSA+IGJhc2VPdXQgLSAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXJyW2ogKyAxXSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ogKyAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IF4gMDtcbiAgICAgICAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmcuXG4gICAgLy8gRS5nLiBhcnJUb1N0ciggWzksIDEwLCAxMV0gKSBiZWNvbWVzICc5YWInIChpbiBiYXNlcyBhYm92ZSAxMSkuXG4gICAgZnVuY3Rpb24gYXJyVG9TdHIoIGFyciApIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgYXJyTCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICBzdHIgPSAnJztcblxuICAgICAgICBmb3IgKCA7IGkgPCBhcnJMOyBzdHIgKz0gRElHSVRTLmNoYXJBdCggYXJyW2krK10gKSApIHtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgaWYgKCBiYXNlSW4gPCAzNyApIHtcbiAgICAgICAgblN0ciA9IG5TdHIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIElmIG5vbi1pbnRlZ2VyIGNvbnZlcnQgaW50ZWdlciBwYXJ0IGFuZCBmcmFjdGlvbiBwYXJ0IHNlcGFyYXRlbHkuXG4gICAgICogQ29udmVydCB0aGUgZnJhY3Rpb24gcGFydCBhcyBpZiBpdCBpcyBhbiBpbnRlZ2VyIHRoYW4gdXNlIGRpdmlzaW9uIHRvXG4gICAgICogcmVkdWNlIGl0IGRvd24gYWdhaW4gdG8gYSB2YWx1ZSBsZXNzIHRoYW4gb25lLlxuICAgICAqL1xuICAgIGlmICggKCBlID0gblN0ci5pbmRleE9mKCAnLicgKSApID4gLTEgKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBwb3dlciB0byB3aGljaCB0byByYWlzZSB0aGUgYmFzZSB0byBnZXQgdGhlIG51bWJlclxuICAgICAgICAgKiB0byBkaXZpZGUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgYWZ0ZXIgaXQgaGFzIGJlZW4gY29udmVydGVkIGFzIGFuXG4gICAgICAgICAqIGludGVnZXIgdG8gdGhlIHJlcXVpcmVkIGJhc2UuXG4gICAgICAgICAqL1xuICAgICAgICBlID0gblN0ci5sZW5ndGggLSBlIC0gMTtcblxuICAgICAgICAvLyBVc2UgdG9GaXhlZCB0byBhdm9pZCBwb3NzaWJsZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAgICAgZHZzID0gc3RyVG9BcnIoIG5ldyBCaWdOdW1iZXIoYmFzZUluKVsncG93J10oZSlbJ3RvRiddKCksIDEwICk7XG5cbiAgICAgICAgbkFyciA9IG5TdHIuc3BsaXQoJy4nKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBiYXNlIG9mIHRoZSBmcmFjdGlvbiBwYXJ0IChhcyBpbnRlZ2VyKS5cbiAgICAgICAgZHZkID0gc3RyVG9BcnIoIG5BcnJbMV0gKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBiYXNlIG9mIHRoZSBpbnRlZ2VyIHBhcnQuXG4gICAgICAgIG5BcnIgPSBzdHJUb0FyciggbkFyclswXSApO1xuXG4gICAgICAgIC8vIFJlc3VsdCB3aWxsIGJlIGEgQmlnTnVtYmVyIHdpdGggYSB2YWx1ZSBsZXNzIHRoYW4gMS5cbiAgICAgICAgZnJhY0JOID0gZGl2aWRlKCBkdmQsIGR2cywgZHZkLmxlbmd0aCAtIGR2cy5sZW5ndGgsIHNpZ24sIGJhc2VPdXQsXG4gICAgICAgICAgLy8gSXMgbGVhc3Qgc2lnbmlmaWNhbnQgZGlnaXQgb2YgaW50ZWdlciBwYXJ0IGFuIG9kZCBudW1iZXI/XG4gICAgICAgICAgbkFycltuQXJyLmxlbmd0aCAtIDFdICYgMSApO1xuXG4gICAgICAgIGZyYWNBcnIgPSBmcmFjQk5bJ2MnXTtcblxuICAgICAgICAvLyBlIGNhbiBiZSA8PSAwICAoIGlmIGUgPT0gMCwgZnJhY0FyciBpcyBbMF0gb3IgWzFdICkuXG4gICAgICAgIGlmICggZSA9IGZyYWNCTlsnZSddICkge1xuXG4gICAgICAgICAgICAvLyBBcHBlbmQgemVyb3MgYWNjb3JkaW5nIHRvIHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgZm9yICggOyArK2U7IGZyYWNBcnIudW5zaGlmdCgwKSApIHtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmcmFjdGlvbiBwYXJ0IHRvIHRoZSBjb252ZXJ0ZWQgaW50ZWdlciBwYXJ0LlxuICAgICAgICAgICAgblN0ciA9IGFyclRvU3RyKG5BcnIpICsgJy4nICsgYXJyVG9TdHIoZnJhY0Fycik7XG5cbiAgICAgICAgLy8gZnJhY0FyciBpcyBbMV0uXG4gICAgICAgIC8vIEZyYWN0aW9uIGRpZ2l0cyByb3VuZGVkIHVwLCBzbyBpbmNyZW1lbnQgbGFzdCBkaWdpdCBvZiBpbnRlZ2VyIHBhcnQuXG4gICAgICAgIH0gZWxzZSBpZiAoIGZyYWNBcnJbMF0gKSB7XG5cbiAgICAgICAgICAgIGlmICggbkFyclsgZSA9IG5BcnIubGVuZ3RoIC0gMSBdIDwgYmFzZU91dCAtIDEgKSB7XG4gICAgICAgICAgICAgICAgKytuQXJyW2VdO1xuICAgICAgICAgICAgICAgIG5TdHIgPSBhcnJUb1N0cihuQXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgblN0ciA9IG5ldyBCaWdOdW1iZXIoIGFyclRvU3RyKG5BcnIpLFxuICAgICAgICAgICAgICAgICAgYmFzZU91dCApWydwbHVzJ10oT05FKVsndG9TJ10oYmFzZU91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gZnJhY0FyciBpcyBbMF0uIE5vIGZyYWN0aW9uIGRpZ2l0cy5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5TdHIgPSBhcnJUb1N0cihuQXJyKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gU2ltcGxlIGludGVnZXIuIENvbnZlcnQgYmFzZS5cbiAgICAgICAgblN0ciA9IGFyclRvU3RyKCBzdHJUb0FycihuU3RyKSApO1xuICAgIH1cblxuICAgIHJldHVybiBuU3RyO1xufVxuXG5cbi8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0LlxuZnVuY3Rpb24gZGl2aWRlKCBkdmQsIGR2cywgZXhwLCBzLCBiYXNlLCBpc09kZCApIHtcbiAgICB2YXIgZHZzTCwgZHZzVCwgbmV4dCwgY21wLCByZW1JLFxuICAgICAgICBkdnNaID0gZHZzLnNsaWNlKCksXG4gICAgICAgIGR2ZEkgPSBkdnNMID0gZHZzLmxlbmd0aCxcbiAgICAgICAgZHZkTCA9IGR2ZC5sZW5ndGgsXG4gICAgICAgIHJlbSA9IGR2ZC5zbGljZSggMCwgZHZzTCApLFxuICAgICAgICByZW1MID0gcmVtLmxlbmd0aCxcbiAgICAgICAgcXVvID0gbmV3IEJpZ051bWJlcihPTkUpLFxuICAgICAgICBxYyA9IHF1b1snYyddID0gW10sXG4gICAgICAgIHFpID0gMCxcbiAgICAgICAgZGlnID0gREVDSU1BTF9QTEFDRVMgKyAoIHF1b1snZSddID0gZXhwICkgKyAxO1xuXG4gICAgcXVvWydzJ10gPSBzO1xuICAgIHMgPSBkaWcgPCAwID8gMCA6IGRpZztcblxuICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXG4gICAgZm9yICggOyByZW1MKysgPCBkdnNMOyByZW0ucHVzaCgwKSApIHtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdmVyc2lvbiBvZiBkaXZpc29yIHdpdGggbGVhZGluZyB6ZXJvLlxuICAgIGR2c1oudW5zaGlmdCgwKTtcblxuICAgIGRvIHtcblxuICAgICAgICAvLyAnbmV4dCcgaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cbiAgICAgICAgZm9yICggbmV4dCA9IDA7IG5leHQgPCBiYXNlOyBuZXh0KysgKSB7XG5cbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxuICAgICAgICAgICAgaWYgKCBkdnNMICE9ICggcmVtTCA9IHJlbS5sZW5ndGggKSApIHtcbiAgICAgICAgICAgICAgICBjbXAgPSBkdnNMID4gcmVtTCA/IDEgOiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggcmVtSSA9IC0xLCBjbXAgPSAwOyArK3JlbUkgPCBkdnNMOyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGR2c1tyZW1JXSAhPSByZW1bcmVtSV0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSBkdnNbcmVtSV0gPiByZW1bcmVtSV0gPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciAoaWYgZGl2aXNvciA8IHJlbWFpbmRlcikuXG4gICAgICAgICAgICBpZiAoIGNtcCA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1haW5kZXIgY2Fubm90IGJlIG1vcmUgdGhhbiBvbmUgZGlnaXQgbG9uZ2VyIHRoYW4gZGl2aXNvci5cbiAgICAgICAgICAgICAgICAvLyBFcXVhbGlzZSBsZW5ndGhzIHVzaW5nIGRpdmlzb3Igd2l0aCBleHRyYSBsZWFkaW5nIHplcm8/XG4gICAgICAgICAgICAgICAgZm9yICggZHZzVCA9IHJlbUwgPT0gZHZzTCA/IGR2cyA6IGR2c1o7IHJlbUw7ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVtWy0tcmVtTF0gPCBkdnNUW3JlbUxdICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCByZW1JID0gcmVtTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtSSAmJiAhcmVtWy0tcmVtSV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtW3JlbUldID0gYmFzZSAtIDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAtLXJlbVtyZW1JXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbVtyZW1MXSArPSBiYXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlbVtyZW1MXSAtPSBkdnNUW3JlbUxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKCA7ICFyZW1bMF07IHJlbS5zaGlmdCgpICkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlICduZXh0JyBkaWdpdCB0byB0aGUgcmVzdWx0IGFycmF5LlxuICAgICAgICBxY1txaSsrXSA9IGNtcCA/IG5leHQgOiArK25leHQ7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXG4gICAgICAgIHJlbVswXSAmJiBjbXBcbiAgICAgICAgICA/ICggcmVtW3JlbUxdID0gZHZkW2R2ZEldIHx8IDAgKVxuICAgICAgICAgIDogKCByZW0gPSBbIGR2ZFtkdmRJXSBdICk7XG5cbiAgICB9IHdoaWxlICggKCBkdmRJKysgPCBkdmRMIHx8IHJlbVswXSAhPSBudWxsICkgJiYgcy0tICk7XG5cbiAgICAvLyBMZWFkaW5nIHplcm8/IERvIG5vdCByZW1vdmUgaWYgcmVzdWx0IGlzIHNpbXBseSB6ZXJvIChxaSA9PSAxKS5cbiAgICBpZiAoICFxY1swXSAmJiBxaSAhPSAxICkge1xuXG4gICAgICAgIC8vIFRoZXJlIGNhbid0IGJlIG1vcmUgdGhhbiBvbmUgemVyby5cbiAgICAgICAgLS1xdW9bJ2UnXTtcbiAgICAgICAgcWMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICAvLyBSb3VuZD9cbiAgICBpZiAoIHFpID4gZGlnICkge1xuICAgICAgICBybmQoIHF1bywgREVDSU1BTF9QTEFDRVMsIGJhc2UsIGlzT2RkLCByZW1bMF0gIT0gbnVsbCApO1xuICAgIH1cblxuICAgIC8vIE92ZXJmbG93P1xuICAgIGlmICggcXVvWydlJ10gPiBNQVhfRVhQICkge1xuXG4gICAgICAgIC8vIEluZmluaXR5LlxuICAgICAgICBxdW9bJ2MnXSA9IHF1b1snZSddID0gbnVsbDtcblxuICAgIC8vIFVuZGVyZmxvdz9cbiAgICB9IGVsc2UgaWYgKCBxdW9bJ2UnXSA8IE1JTl9FWFAgKSB7XG5cbiAgICAgICAgLy8gWmVyby5cbiAgICAgICAgcXVvWydjJ10gPSBbcXVvWydlJ10gPSAwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvO1xufVxuXG5cbi8qXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBub3JtYWwgb3JcbiAqIGV4cG9uZW50aWFsIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvclxuICogc2lnbmlmaWNhbnQgZGlnaXRzLlxuICogQ2FsbGVkIGJ5IHRvU3RyaW5nLCB0b0V4cG9uZW50aWFsIChleHAgMSksIHRvRml4ZWQsIGFuZCB0b1ByZWNpc2lvbiAoZXhwIDIpLlxuICogZCBpcyB0aGUgaW5kZXggKHdpdGggdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbikgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlXG4gKiByb3VuZGVkIHVwLlxuICovXG5mdW5jdGlvbiBmb3JtYXQoIG4sIGQsIGV4cCApIHtcblxuICAgIC8vIEluaXRpYWxseSwgaSBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHJlcXVpcmVkLlxuICAgIHZhciBpID0gZCAtIChuID0gbmV3IEJpZ051bWJlcihuKSlbJ2UnXSxcbiAgICAgICAgYyA9IG5bJ2MnXTtcblxuICAgIC8vICstSW5maW5pdHkgb3IgTmFOP1xuICAgIGlmICggIWMgKSB7XG4gICAgICAgIHJldHVybiBuWyd0b1MnXSgpO1xuICAgIH1cblxuICAgIC8vIFJvdW5kP1xuICAgIGlmICggYy5sZW5ndGggPiArK2QgKSB7XG4gICAgICAgIHJuZCggbiwgaSwgMTAgKTtcbiAgICB9XG5cbiAgICAvLyBSZWNhbGN1bGF0ZSBkIGlmIHRvRml4ZWQgYXMgblsnZSddIG1heSBoYXZlIGNoYW5nZWQgaWYgdmFsdWUgcm91bmRlZCB1cC5cbiAgICBpID0gY1swXSA9PSAwID8gaSArIDEgOiBleHAgPyBkIDogblsnZSddICsgaSArIDE7XG5cbiAgICAvLyBBcHBlbmQgemVyb3M/XG4gICAgZm9yICggOyBjLmxlbmd0aCA8IGk7IGMucHVzaCgwKSApIHtcbiAgICB9XG4gICAgaSA9IG5bJ2UnXTtcblxuICAgIC8qXG4gICAgICogdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50XG4gICAgICogZGlnaXRzIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvXG4gICAgICogcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbi5cbiAgICAgKi9cbiAgICByZXR1cm4gZXhwID09IDEgfHwgZXhwID09IDIgJiYgKCAtLWQgPCBpIHx8IGkgPD0gVE9fRVhQX05FRyApXG5cbiAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAgICAgPyAoIG5bJ3MnXSA8IDAgJiYgY1swXSA/ICctJyA6ICcnICkgKyAoIGMubGVuZ3RoID4gMVxuICAgICAgICA/ICggYy5zcGxpY2UoIDEsIDAsICcuJyApLCBjLmpvaW4oJycpIClcbiAgICAgICAgOiBjWzBdICkgKyAoIGkgPCAwID8gJ2UnIDogJ2UrJyApICsgaVxuXG4gICAgICAvLyBOb3JtYWwgbm90YXRpb24uXG4gICAgICA6IG5bJ3RvUyddKCk7XG59XG5cblxuLy8gUm91bmQgaWYgbmVjZXNzYXJ5LlxuLy8gQ2FsbGVkIGJ5IGRpdmlkZSwgZm9ybWF0LCBzZXRNb2RlIGFuZCBzcXJ0LlxuZnVuY3Rpb24gcm5kKCB4LCBkcCwgYmFzZSwgaXNPZGQsIHIgKSB7XG4gICAgdmFyIHhjID0geFsnYyddLFxuICAgICAgICBpc05lZyA9IHhbJ3MnXSA8IDAsXG4gICAgICAgIGhhbGYgPSBiYXNlIC8gMixcbiAgICAgICAgaSA9IHhbJ2UnXSArIGRwICsgMSxcblxuICAgICAgICAvLyAnbmV4dCcgaXMgdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxuICAgICAgICBuZXh0ID0geGNbaV0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICogJ21vcmUnIGlzIHdoZXRoZXIgdGhlcmUgYXJlIGRpZ2l0cyBhZnRlciAnbmV4dCcuXG4gICAgICAgICAqIEUuZy5cbiAgICAgICAgICogMC4wMDUgKGUgPSAtMykgdG8gYmUgcm91bmRlZCB0byAwIGRlY2ltYWwgcGxhY2VzIChkcCA9IDApIGdpdmVzIGkgPSAtMlxuICAgICAgICAgKiBUaGUgJ25leHQnIGRpZ2l0IGlzIHplcm8sIGFuZCB0aGVyZSBBUkUgJ21vcmUnIGRpZ2l0cyBhZnRlciBpdC5cbiAgICAgICAgICogMC41IChlID0gLTEpIGRwID0gMCBnaXZlcyBpID0gMFxuICAgICAgICAgKiBUaGUgJ25leHQnIGRpZ2l0IGlzIDUgYW5kIHRoZXJlIGFyZSBubyAnbW9yZScgZGlnaXRzIGFmdGVyIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgbW9yZSA9IHIgfHwgaSA8IDAgfHwgeGNbaSArIDFdICE9IG51bGw7XG5cbiAgICByID0gUk9VTkRJTkdfTU9ERSA8IDRcbiAgICAgID8gKCBuZXh0ICE9IG51bGwgfHwgbW9yZSApICYmXG4gICAgICAgICggUk9VTkRJTkdfTU9ERSA9PSAwIHx8XG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMiAmJiAhaXNOZWcgfHxcbiAgICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgJiYgaXNOZWcgKVxuICAgICAgOiBuZXh0ID4gaGFsZiB8fCBuZXh0ID09IGhhbGYgJiZcbiAgICAgICAgKCBST1VORElOR19NT0RFID09IDQgfHwgbW9yZSB8fFxuXG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBpc09kZCBpcyB1c2VkIGluIGJhc2UgY29udmVyc2lvbiBhbmQgcmVmZXJzIHRvIHRoZSBsZWFzdCBzaWduaWZpY2FudFxuICAgICAgICAgICAqIGRpZ2l0IG9mIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZC4gVGhlIGZyYWN0aW9uXG4gICAgICAgICAgICogcGFydCBpcyByb3VuZGVkIGJ5IHRoaXMgbWV0aG9kIHNlcGFyYXRlbHkgZnJvbSB0aGUgaW50ZWdlciBwYXJ0LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gNiAmJiAoIHhjW2kgLSAxXSAmIDEgfHwgIWRwICYmIGlzT2RkICkgfHxcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gNyAmJiAhaXNOZWcgfHxcbiAgICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSA4ICYmIGlzTmVnICk7XG5cbiAgICBpZiAoIGkgPCAxIHx8ICF4Y1swXSApIHtcbiAgICAgICAgeGMubGVuZ3RoID0gMDtcbiAgICAgICAgeGMucHVzaCgwKTtcblxuICAgICAgICBpZiAoIHIgKSB7XG5cbiAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXG4gICAgICAgICAgICB4Y1swXSA9IDE7XG4gICAgICAgICAgICB4WydlJ10gPSAtZHA7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIFplcm8uXG4gICAgICAgICAgICB4WydlJ10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBkaWdpdHMgYWZ0ZXIgdGhlIHJlcXVpcmVkIGRlY2ltYWwgcGxhY2VzLlxuICAgIHhjLmxlbmd0aCA9IGktLTtcblxuICAgIC8vIFJvdW5kIHVwP1xuICAgIGlmICggciApIHtcblxuICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxuICAgICAgICBmb3IgKCAtLWJhc2U7ICsreGNbaV0gPiBiYXNlOyApIHtcbiAgICAgICAgICAgIHhjW2ldID0gMDtcblxuICAgICAgICAgICAgaWYgKCAhaS0tICkge1xuICAgICAgICAgICAgICAgICsreFsnZSddO1xuICAgICAgICAgICAgICAgIHhjLnVuc2hpZnQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXG4gICAgZm9yICggaSA9IHhjLmxlbmd0aDsgIXhjWy0taV07IHhjLnBvcCgpICkge1xuICAgIH1cblxuICAgIHJldHVybiB4O1xufVxuXG5cbi8vIFJvdW5kIGFmdGVyIHNldHRpbmcgdGhlIGFwcHJvcHJpYXRlIHJvdW5kaW5nIG1vZGUuXG4vLyBIYW5kbGVzIGNlaWwsIGZsb29yIGFuZCByb3VuZC5cbmZ1bmN0aW9uIHNldE1vZGUoIHgsIGRwLCBybSApIHtcbiAgICB2YXIgciA9IFJPVU5ESU5HX01PREU7XG5cbiAgICBST1VORElOR19NT0RFID0gcm07XG4gICAgeCA9IG5ldyBCaWdOdW1iZXIoeCk7XG4gICAgeFsnYyddICYmIHJuZCggeCwgZHAsIDEwICk7XG4gICAgUk9VTkRJTkdfTU9ERSA9IHI7XG5cbiAgICByZXR1cm4geDtcbn1cblxuXG4vLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xuXG5cbi8qXG4gKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cbiAqL1xuUFsnYWJzJ10gPSBQWydhYnNvbHV0ZVZhbHVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xuXG4gICAgaWYgKCB4WydzJ10gPCAwICkge1xuICAgICAgICB4WydzJ10gPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB4O1xufTtcblxuLypcbiAqIFJldHVybiB0aGUgYml0IGxlbmd0aCBvZiB0aGUgbnVtYmVyLlxuICovXG5QWydiaXRMZW5ndGgnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygyKS5sZW5ndGg7XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlclxuICogcm91bmRlZCB0byBhIHdob2xlIG51bWJlciBpbiB0aGUgZGlyZWN0aW9uIG9mIEluZmluaXR5LlxuICovXG5QWydjZWlsJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldE1vZGUoIHRoaXMsIDAsIDIgKTtcbn07XG5cblxuLypcbiAqIFJldHVyblxuICogMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXG4gKiAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXG4gKiAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcbiAqIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXG4gKi9cblBbJ2NvbXBhcmVkVG8nXSA9IFBbJ2NtcCddID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgIHZhciBhLFxuICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgeGMgPSB4WydjJ10sXG4gICAgICAgIHljID0gKCBpZCA9IC1pZCwgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKSApWydjJ10sXG4gICAgICAgIGkgPSB4WydzJ10sXG4gICAgICAgIGogPSB5WydzJ10sXG4gICAgICAgIGsgPSB4WydlJ10sXG4gICAgICAgIGwgPSB5WydlJ107XG5cbiAgICAvLyBFaXRoZXIgTmFOP1xuICAgIGlmICggIWkgfHwgIWogKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGEgPSB4YyAmJiAheGNbMF0sIGIgPSB5YyAmJiAheWNbMF07XG5cbiAgICAvLyBFaXRoZXIgemVybz9cbiAgICBpZiAoIGEgfHwgYiApIHtcbiAgICAgICAgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcbiAgICB9XG5cbiAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgaWYgKCBpICE9IGogKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cbiAgICBpZiAoIGEgPSBpIDwgMCwgYiA9IGsgPT0gbCwgIXhjIHx8ICF5YyApIHtcbiAgICAgICAgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cbiAgICBpZiAoICFiICkge1xuICAgICAgICByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xuICAgIH1cblxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXG4gICAgZm9yICggaSA9IC0xLFxuICAgICAgICAgIGogPSAoIGsgPSB4Yy5sZW5ndGggKSA8ICggbCA9IHljLmxlbmd0aCApID8gayA6IGw7XG4gICAgICAgICAgKytpIDwgajsgKSB7XG5cbiAgICAgICAgaWYgKCB4Y1tpXSAhPSB5Y1tpXSApIHtcbiAgICAgICAgICAgIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XG59O1xuXG5cbi8qXG4gKiAgbiAvIDAgPSBJXG4gKiAgbiAvIE4gPSBOXG4gKiAgbiAvIEkgPSAwXG4gKiAgMCAvIG4gPSAwXG4gKiAgMCAvIDAgPSBOXG4gKiAgMCAvIE4gPSBOXG4gKiAgMCAvIEkgPSAwXG4gKiAgTiAvIG4gPSBOXG4gKiAgTiAvIDAgPSBOXG4gKiAgTiAvIE4gPSBOXG4gKiAgTiAvIEkgPSBOXG4gKiAgSSAvIG4gPSBJXG4gKiAgSSAvIDAgPSBJXG4gKiAgSSAvIE4gPSBOXG4gKiAgSSAvIEkgPSBOXG4gKlxuICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXJcbiAqIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG9cbiAqIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxuICovXG5QWydkaXZpZGVkQnknXSA9IFBbJ2RpdiddID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgIHZhciB4YyA9IHRoaXNbJ2MnXSxcbiAgICAgICAgeGUgPSB0aGlzWydlJ10sXG4gICAgICAgIHhzID0gdGhpc1sncyddLFxuICAgICAgICB5YyA9ICggaWQgPSAyLCB5ID0gbmV3IEJpZ051bWJlciggeSwgYiApIClbJ2MnXSxcbiAgICAgICAgeWUgPSB5WydlJ10sXG4gICAgICAgIHlzID0geVsncyddLFxuICAgICAgICBzID0geHMgPT0geXMgPyAxIDogLTE7XG5cbiAgICAvLyBFaXRoZXIgTmFOL0luZmluaXR5LzA/XG4gICAgcmV0dXJuICF4ZSAmJiAoICF4YyB8fCAheGNbMF0gKSB8fCAheWUgJiYgKCAheWMgfHwgIXljWzBdIClcblxuICAgICAgLy8gRWl0aGVyIE5hTj9cbiAgICAgID8gbmV3IEJpZ051bWJlciggIXhzIHx8ICF5cyB8fFxuXG4gICAgICAgIC8vIEJvdGggMCBvciBib3RoIEluZmluaXR5P1xuICAgICAgICAoIHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMgKVxuXG4gICAgICAgICAgLy8gUmV0dXJuIE5hTi5cbiAgICAgICAgICA/IE5hTlxuXG4gICAgICAgICAgLy8geCBpcyAwIG9yIHkgaXMgSW5maW5pdHk/XG4gICAgICAgICAgOiB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5Y1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gKy0wLlxuICAgICAgICAgICAgPyBzICogMFxuXG4gICAgICAgICAgICAvLyB5IGlzIDAuIFJldHVybiArLUluZmluaXR5LlxuICAgICAgICAgICAgOiBzIC8gMCApXG5cbiAgICAgIDogZGl2aWRlKCB4YywgeWMsIHhlIC0geWUsIHMsIDEwICk7XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXG4gKiBCaWdOdW1iZXIobiwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICovXG5QWydlcXVhbHMnXSA9IFBbJ2VxJ10gPSBmdW5jdGlvbiAoIG4sIGIgKSB7XG4gICAgaWQgPSAzO1xuICAgIHJldHVybiB0aGlzWydjbXAnXSggbiwgYiApID09PSAwO1xufTtcblxuXG4vKlxuICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXJcbiAqIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiAtSW5maW5pdHkuXG4gKi9cblBbJ2Zsb29yJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldE1vZGUoIHRoaXMsIDAsIDMgKTtcbn07XG5cblxuLypcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mXG4gKiBCaWdOdW1iZXIobiwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICovXG5QWydncmVhdGVyVGhhbiddID0gUFsnZ3QnXSA9IGZ1bmN0aW9uICggbiwgYiApIHtcbiAgICBpZCA9IDQ7XG4gICAgcmV0dXJuIHRoaXNbJ2NtcCddKCBuLCBiICkgPiAwO1xufTtcblxuXG4vKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICogdGhlIHZhbHVlIG9mIEJpZ051bWJlcihuLCBiKSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gKi9cblBbJ2dyZWF0ZXJUaGFuT3JFcXVhbFRvJ10gPSBQWydndGUnXSA9IFBbJ2d0J10gPSBmdW5jdGlvbiAoIG4sIGIgKSB7XG4gICAgaWQgPSA1O1xuICAgIHJldHVybiAoIGIgPSB0aGlzWydjbXAnXSggbiwgYiApICkgPT0gMSB8fCBiID09PSAwO1xufTtcblxuXG4vKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlXG4gKiByZXR1cm5zIGZhbHNlLlxuICovXG5QWydpc0Zpbml0ZSddID0gUFsnaXNGJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpc1snYyddO1xufTtcblxuXG4vKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybnNcbiAqIGZhbHNlLlxuICovXG5QWydpc05hTiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpc1sncyddO1xufTtcblxuXG4vKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2VcbiAqIHJldHVybnMgZmFsc2UuXG4gKi9cblBbJ2lzTmVnYXRpdmUnXSA9IFBbJ2lzTmVnJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbJ3MnXSA8IDA7XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybnNcbiAqIGZhbHNlLlxuICovXG5QWydpc1plcm8nXSA9IFBbJ2lzWiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXNbJ2MnXSAmJiB0aGlzWydjJ11bMF0gPT0gMDtcbn07XG5cblxuLypcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mXG4gKiBCaWdOdW1iZXIobiwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICovXG5QWydsZXNzVGhhbiddID0gUFsnbHQnXSA9IGZ1bmN0aW9uICggbiwgYiApIHtcbiAgICBpZCA9IDY7XG4gICAgcmV0dXJuIHRoaXNbJ2NtcCddKCBuLCBiICkgPCAwO1xufTtcblxuXG4vKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAqIHZhbHVlIG9mIEJpZ051bWJlcihuLCBiKSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gKi9cblBbJ2xlc3NUaGFuT3JFcXVhbFRvJ10gPSBQWydsdGUnXSA9IFBbJ2xlJ10gPSBmdW5jdGlvbiAoIG4sIGIgKSB7XG4gICAgaWQgPSA3O1xuICAgIHJldHVybiAoIGIgPSB0aGlzWydjbXAnXSggbiwgYiApICkgPT0gLTEgfHwgYiA9PT0gMDtcbn07XG5cblxuLypcbiAqICBuIC0gMCA9IG5cbiAqICBuIC0gTiA9IE5cbiAqICBuIC0gSSA9IC1JXG4gKiAgMCAtIG4gPSAtblxuICogIDAgLSAwID0gMFxuICogIDAgLSBOID0gTlxuICogIDAgLSBJID0gLUlcbiAqICBOIC0gbiA9IE5cbiAqICBOIC0gMCA9IE5cbiAqICBOIC0gTiA9IE5cbiAqICBOIC0gSSA9IE5cbiAqICBJIC0gbiA9IElcbiAqICBJIC0gMCA9IElcbiAqICBJIC0gTiA9IE5cbiAqICBJIC0gSSA9IE5cbiAqXG4gKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51c1xuICogdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cbiAqL1xuUFsnbWludXMnXSA9IFBbJ3N1YiddID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgIHZhciBkLCBpLCBqLCB4TFR5LFxuICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgYSA9IHhbJ3MnXTtcblxuICAgIGIgPSAoIGlkID0gOCwgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKSApWydzJ107XG5cbiAgICAvLyBFaXRoZXIgTmFOP1xuICAgIGlmICggIWEgfHwgIWIgKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG4gICAgfVxuXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xuICAgIGlmICggYSAhPSBiICkge1xuICAgICAgICByZXR1cm4geVsncyddID0gLWIsIHhbJ3BsdXMnXSh5KTtcbiAgICB9XG5cbiAgICB2YXIgeGMgPSB4WydjJ10sXG4gICAgICAgIHhlID0geFsnZSddLFxuICAgICAgICB5YyA9IHlbJ2MnXSxcbiAgICAgICAgeWUgPSB5WydlJ107XG5cbiAgICBpZiAoICF4ZSB8fCAheWUgKSB7XG5cbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xuICAgICAgICBpZiAoICF4YyB8fCAheWMgKSB7XG4gICAgICAgICAgICByZXR1cm4geGMgPyAoIHlbJ3MnXSA9IC1iLCB5ICkgOiBuZXcgQmlnTnVtYmVyKCB5YyA/IHggOiBOYU4gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoICF4Y1swXSB8fCAheWNbMF0gKSB7XG5cbiAgICAgICAgICAgIC8vIHkgaXMgbm9uLXplcm8/XG4gICAgICAgICAgICByZXR1cm4geWNbMF1cbiAgICAgICAgICAgICAgPyAoIHlbJ3MnXSA9IC1iLCB5IClcblxuICAgICAgICAgICAgICAvLyB4IGlzIG5vbi16ZXJvP1xuICAgICAgICAgICAgICA6IG5ldyBCaWdOdW1iZXIoIHhjWzBdXG4gICAgICAgICAgICAgICAgPyB4XG5cbiAgICAgICAgICAgICAgICAvLyBCb3RoIGFyZSB6ZXJvLlxuICAgICAgICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcbiAgICAgICAgICAgICAgICA6IFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxuICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxuICAgIGlmICggeGMgPSB4Yy5zbGljZSgpLCBhID0geGUgLSB5ZSApIHtcbiAgICAgICAgZCA9ICggeExUeSA9IGEgPCAwICkgPyAoIGEgPSAtYSwgeGMgKSA6ICggeWUgPSB4ZSwgeWMgKTtcblxuICAgICAgICBmb3IgKCBkLnJldmVyc2UoKSwgYiA9IGE7IGItLTsgZC5wdXNoKDApICkge1xuICAgICAgICB9XG4gICAgICAgIGQucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cbiAgICAgICAgaiA9ICggKCB4TFR5ID0geGMubGVuZ3RoIDwgeWMubGVuZ3RoICkgPyB4YyA6IHljICkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIGEgPSBiID0gMDsgYiA8IGo7IGIrKyApIHtcblxuICAgICAgICAgICAgaWYgKCB4Y1tiXSAhPSB5Y1tiXSApIHtcbiAgICAgICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXG4gICAgaWYgKCB4TFR5ICkge1xuICAgICAgICBkID0geGMsIHhjID0geWMsIHljID0gZDtcbiAgICAgICAgeVsncyddID0gLXlbJ3MnXTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLiBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyXG4gICAgICogYXMgc3VidHJhY3Rpb24gb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXG4gICAgICovXG4gICAgaWYgKCAoIGIgPSAtKCAoIGogPSB4Yy5sZW5ndGggKSAtIHljLmxlbmd0aCApICkgPiAwICkge1xuXG4gICAgICAgIGZvciAoIDsgYi0tOyB4Y1tqKytdID0gMCApIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXG4gICAgZm9yICggYiA9IHljLmxlbmd0aDsgYiA+IGE7ICl7XG5cbiAgICAgICAgaWYgKCB4Y1stLWJdIDwgeWNbYl0gKSB7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSBiOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IDkgKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAtLXhjW2ldO1xuICAgICAgICAgICAgeGNbYl0gKz0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgeGNbYl0gLT0geWNbYl07XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxuICAgIGZvciAoIDsgeGNbLS1qXSA9PSAwOyB4Yy5wb3AoKSApIHtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxuICAgIGZvciAoIDsgeGNbMF0gPT0gMDsgeGMuc2hpZnQoKSwgLS15ZSApIHtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxuICAgICAqIHdoZW4gbmVpdGhlciB4IG9yIHkgYXJlIEluZmluaXR5LlxuICAgICAqL1xuXG4gICAgLy8gVW5kZXJmbG93P1xuICAgIGlmICggeWUgPCBNSU5fRVhQIHx8ICF4Y1swXSApIHtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcbiAgICAgICAgICogbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoICF4Y1swXSApIHtcbiAgICAgICAgICAgIHlbJ3MnXSA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc3VsdCBpcyB6ZXJvLlxuICAgICAgICB4YyA9IFt5ZSA9IDBdO1xuICAgIH1cblxuICAgIHJldHVybiB5WydjJ10gPSB4YywgeVsnZSddID0geWUsIHk7XG59O1xuXG5cbi8qXG4gKiAgIG4gJSAwID0gIE5cbiAqICAgbiAlIE4gPSAgTlxuICogICAwICUgbiA9ICAwXG4gKiAgLTAgJSBuID0gLTBcbiAqICAgMCAlIDAgPSAgTlxuICogICAwICUgTiA9ICBOXG4gKiAgIE4gJSBuID0gIE5cbiAqICAgTiAlIDAgPSAgTlxuICogICBOICUgTiA9ICBOXG4gKlxuICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvXG4gKiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxuICovXG5QWydtb2R1bG8nXSA9IFBbJ21vZCddID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgIHZhciB4ID0gdGhpcyxcbiAgICAgICAgeGMgPSB4WydjJ10sXG4gICAgICAgIHljID0gKCBpZCA9IDksIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKVsnYyddLFxuICAgICAgICBpID0geFsncyddLFxuICAgICAgICBqID0geVsncyddO1xuXG4gICAgLy8gSXMgeCBvciB5IE5hTiwgb3IgeSB6ZXJvP1xuICAgIGIgPSAhaSB8fCAhaiB8fCB5YyAmJiAheWNbMF07XG5cbiAgICBpZiAoIGIgfHwgeGMgJiYgIXhjWzBdICkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggYiA/IE5hTiA6IHggKTtcbiAgICB9XG5cbiAgICB4WydzJ10gPSB5WydzJ10gPSAxO1xuICAgIGIgPSB5WydjbXAnXSh4KSA9PSAxO1xuICAgIHhbJ3MnXSA9IGksIHlbJ3MnXSA9IGo7XG5cbiAgICByZXR1cm4gYlxuICAgICAgPyBuZXcgQmlnTnVtYmVyKHgpXG4gICAgICA6ICggaSA9IERFQ0lNQUxfUExBQ0VTLCBqID0gUk9VTkRJTkdfTU9ERSxcbiAgICAgICAgREVDSU1BTF9QTEFDRVMgPSAwLCBST1VORElOR19NT0RFID0gMSxcbiAgICAgICAgICB4ID0geFsnZGl2J10oeSksXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IGksIFJPVU5ESU5HX01PREUgPSBqLFxuICAgICAgICAgICAgICB0aGlzWydtaW51cyddKCB4Wyd0aW1lcyddKHkpICkgKTtcbn07XG5cblxuLypcbiAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyXG4gKiBuZWdhdGVkLCBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXG4gKi9cblBbJ25lZ2F0ZWQnXSA9IFBbJ25lZyddID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcblxuICAgIHJldHVybiB4WydzJ10gPSAteFsncyddIHx8IG51bGwsIHg7XG59O1xuXG5cbi8qXG4gKiAgbiArIDAgPSBuXG4gKiAgbiArIE4gPSBOXG4gKiAgbiArIEkgPSBJXG4gKiAgMCArIG4gPSBuXG4gKiAgMCArIDAgPSAwXG4gKiAgMCArIE4gPSBOXG4gKiAgMCArIEkgPSBJXG4gKiAgTiArIG4gPSBOXG4gKiAgTiArIDAgPSBOXG4gKiAgTiArIE4gPSBOXG4gKiAgTiArIEkgPSBOXG4gKiAgSSArIG4gPSBJXG4gKiAgSSArIDAgPSBJXG4gKiAgSSArIE4gPSBOXG4gKiAgSSArIEkgPSBJXG4gKlxuICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1c1xuICogdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cbiAqL1xuUFsncGx1cyddID0gUFsnYWRkJ10gPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgdmFyIGQsXG4gICAgICAgIHggPSB0aGlzLFxuICAgICAgICBhID0geFsncyddO1xuXG4gICAgYiA9ICggaWQgPSAxMCwgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKSApWydzJ107XG5cbiAgICAvLyBFaXRoZXIgTmFOP1xuICAgIGlmICggIWEgfHwgIWIgKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG4gICAgfVxuXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xuICAgIGlmICggYSAhPSBiICkge1xuICAgICAgICByZXR1cm4geVsncyddID0gLWIsIHhbJ21pbnVzJ10oeSk7XG4gICAgfVxuXG4gICAgdmFyIHhlID0geFsnZSddLFxuICAgICAgICB4YyA9IHhbJ2MnXSxcbiAgICAgICAgeWUgPSB5WydlJ10sXG4gICAgICAgIHljID0geVsnYyddO1xuXG4gICAgaWYgKCAheGUgfHwgIXllICkge1xuXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cbiAgICAgICAgaWYgKCAheGMgfHwgIXljICkge1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gKy1JbmZpbml0eS5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCBhIC8gMCApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XG4gICAgICAgIGlmICggIXhjWzBdIHx8ICF5Y1swXSApIHtcblxuICAgICAgICAgICAgLy8geSBpcyBub24temVybz9cbiAgICAgICAgICAgIHJldHVybiB5Y1swXVxuICAgICAgICAgICAgICA/IHlcblxuICAgICAgICAgICAgICAvLyB4IGlzIG5vbi16ZXJvP1xuICAgICAgICAgICAgICA6IG5ldyBCaWdOdW1iZXIoIHhjWzBdXG4gICAgICAgICAgICAgICAgPyB4XG5cbiAgICAgICAgICAgICAgICAvLyBCb3RoIGFyZSB6ZXJvLiBSZXR1cm4gemVyby5cbiAgICAgICAgICAgICAgICA6IGEgKiAwICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cbiAgICAvLyBOb3RlOiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cbiAgICBpZiAoIHhjID0geGMuc2xpY2UoKSwgYSA9IHhlIC0geWUgKSB7XG4gICAgICAgIGQgPSBhID4gMCA/ICggeWUgPSB4ZSwgeWMgKSA6ICggYSA9IC1hLCB4YyApO1xuXG4gICAgICAgIGZvciAoIGQucmV2ZXJzZSgpOyBhLS07IGQucHVzaCgwKSApIHtcbiAgICAgICAgfVxuICAgICAgICBkLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LlxuICAgIGlmICggeGMubGVuZ3RoIC0geWMubGVuZ3RoIDwgMCApIHtcbiAgICAgICAgZCA9IHljLCB5YyA9IHhjLCB4YyA9IGQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZVxuICAgICAqIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBsZWZ0IGFzIHRoZXkgYXJlLlxuICAgICAqL1xuICAgIGZvciAoIGEgPSB5Yy5sZW5ndGgsIGIgPSAwOyBhO1xuICAgICAgICAgYiA9ICggeGNbLS1hXSA9IHhjW2FdICsgeWNbYV0gKyBiICkgLyAxMCBeIDAsIHhjW2FdICU9IDEwICkge1xuICAgIH1cblxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcblxuICAgIGlmICggYiApIHtcbiAgICAgICAgeGMudW5zaGlmdChiKTtcblxuICAgICAgICAvLyBPdmVyZmxvdz8gKE1BWF9FWFAgKyAxIHBvc3NpYmxlKVxuICAgICAgICBpZiAoICsreWUgPiBNQVhfRVhQICkge1xuXG4gICAgICAgICAgICAvLyBJbmZpbml0eS5cbiAgICAgICAgICAgIHhjID0geWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cbiAgICBmb3IgKCBhID0geGMubGVuZ3RoOyB4Y1stLWFdID09IDA7IHhjLnBvcCgpICkge1xuICAgIH1cblxuICAgIHJldHVybiB5WydjJ10gPSB4YywgeVsnZSddID0geWUsIHk7XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJhaXNlZCB0b1xuICogdGhlIHBvd2VyIGUuIElmIGUgaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxuICogUk9VTkRJTkdfTU9ERS5cbiAqXG4gKiBlIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfUE9XRVIgdG8gTUFYX1BPV0VSIGluY2x1c2l2ZS5cbiAqL1xuUFsndG9Qb3dlciddID0gUFsncG93J10gPSBmdW5jdGlvbiAoIGUgKSB7XG5cbiAgICAvLyBlIHRvIGludGVnZXIsIGF2b2lkaW5nIE5hTiBvciBJbmZpbml0eSBiZWNvbWluZyAwLlxuICAgIHZhciBpID0gZSAqIDAgPT0gMCA/IGUgfCAwIDogZSxcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyksXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XG5cbiAgICAvLyBVc2UgTWF0aC5wb3c/XG4gICAgLy8gUGFzcyArLUluZmluaXR5IGZvciBvdXQgb2YgcmFuZ2UgZXhwb25lbnRzLlxuICAgIGlmICggKCAoICggb3V0T2ZSYW5nZSA9IGUgPCAtTUFYX1BPV0VSIHx8IGUgPiBNQVhfUE9XRVIgKSAmJlxuICAgICAgKGkgPSBlICogMSAvIDApICkgfHxcblxuICAgICAgICAgLypcbiAgICAgICAgICAqIEFueSBleHBvbmVudCB0aGF0IGZhaWxzIHRoZSBwYXJzZSBiZWNvbWVzIE5hTi5cbiAgICAgICAgICAqXG4gICAgICAgICAgKiBJbmNsdWRlICdlICE9PSAwJyBiZWNhdXNlIG9uIE9wZXJhIC0wID09IHBhcnNlRmxvYXQoLTApIGlzIGZhbHNlLFxuICAgICAgICAgICogZGVzcGl0ZSAtMCA9PT0gcGFyc2VGbG9hdCgtMCkgJiYgLTAgPT0gcGFyc2VGbG9hdCgnLTAnKSBpcyB0cnVlLlxuICAgICAgICAgICovXG4gICAgICAgICBwYXJzZShlKSAhPSBlICYmIGUgIT09IDAgJiYgIShpID0gTmFOKSApICYmXG5cbiAgICAgICAgICAvLyAncG93KCkgZXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtlfSdcbiAgICAgICAgICAvLyAncG93KCkgZXhwb25lbnQgb3V0IG9mIHJhbmdlOiB7ZX0nXG4gICAgICAgICAgIWlmRXhjZXB0aW9uc1Rocm93KCBlLCAnZXhwb25lbnQnLCAncG93JyApIHx8XG5cbiAgICAgICAgICAgIC8vIFBhc3MgemVybyB0byBNYXRoLnBvdywgYXMgYW55IHZhbHVlIHRvIHRoZSBwb3dlciB6ZXJvIGlzIDEuXG4gICAgICAgICAgICAhaSApIHtcblxuICAgICAgICAvLyBpIGlzICstSW5maW5pdHksIE5hTiBvciAwLlxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggTWF0aC5wb3coIHhbJ3RvUyddKCksIGkgKSApO1xuICAgIH1cblxuICAgIGZvciAoIGkgPSBpIDwgMCA/IC1pIDogaTsgOyApIHtcblxuICAgICAgICBpZiAoIGkgJiAxICkge1xuICAgICAgICAgICAgeSA9IHlbJ3RpbWVzJ10oeCk7XG4gICAgICAgIH1cbiAgICAgICAgaSA+Pj0gMTtcblxuICAgICAgICBpZiAoICFpICkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IHhbJ3RpbWVzJ10oeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGUgPCAwID8gT05FWydkaXYnXSh5KSA6IHk7XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJhaXNlZCB0b1xuICogdGhlIHBvd2VyIG0gbW9kdWxvIG4uXG4gKlxuICogbSB7QmlnTnVtYmVyfSB0aGUgdmFsdWUgdG8gdGFrZSB0aGUgcG93ZXIgb2ZcbiAqIG4ge0JpZ051bWJlcn0gdGhlIHZhbHVlIHRvIG1vZHVsbyBieVxuICovXG5QWydwb3dtJ10gPSBmdW5jdGlvbiAoIG0sIG4gKSB7XG4gICAgcmV0dXJuIHRoaXMucG93KG0pLm1vZChuKTtcbn07XG5cblxuLypcbiAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyXG4gKiByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciB0b1xuICogMCBhbmQgUk9VTkRJTkdfTU9ERSByZXNwZWN0aXZlbHkgaWYgb21pdHRlZC5cbiAqXG4gKiBbZHBdIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cbiAqIFtybV0ge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cbiAqL1xuUFsncm91bmQnXSA9IGZ1bmN0aW9uICggZHAsIHJtICkge1xuXG4gICAgZHAgPSBkcCA9PSBudWxsIHx8ICggKCAoIG91dE9mUmFuZ2UgPSBkcCA8IDAgfHwgZHAgPiBNQVggKSB8fFxuICAgICAgcGFyc2UoZHApICE9IGRwICkgJiZcblxuICAgICAgICAvLyAncm91bmQoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXG4gICAgICAgIC8vICdyb3VuZCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xuICAgICAgICAhaWZFeGNlcHRpb25zVGhyb3coIGRwLCAnZGVjaW1hbCBwbGFjZXMnLCAncm91bmQnICkgKVxuICAgICAgICAgID8gMFxuICAgICAgICAgIDogZHAgfCAwO1xuXG4gICAgcm0gPSBybSA9PSBudWxsIHx8ICggKCAoIG91dE9mUmFuZ2UgPSBybSA8IDAgfHwgcm0gPiA4ICkgfHxcblxuICAgICAgLy8gSW5jbHVkZSAnJiYgcm0gIT09IDAnIGJlY2F1c2Ugd2l0aCBPcGVyYSAtMCA9PSBwYXJzZUZsb2F0KC0wKSBpcyBmYWxzZS5cbiAgICAgIHBhcnNlKHJtKSAhPSBybSAmJiBybSAhPT0gMCApICYmXG5cbiAgICAgICAgLy8gJ3JvdW5kKCkgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcbiAgICAgICAgLy8gJ3JvdW5kKCkgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXG4gICAgICAgICFpZkV4Y2VwdGlvbnNUaHJvdyggcm0sICdtb2RlJywgJ3JvdW5kJyApIClcbiAgICAgICAgICA/IFJPVU5ESU5HX01PREVcbiAgICAgICAgICA6IHJtIHwgMDtcblxuICAgIHJldHVybiBzZXRNb2RlKCB0aGlzLCBkcCwgcm0gKTtcbn07XG5cblxuLypcbiAqICBzcXJ0KC1uKSA9ICBOXG4gKiAgc3FydCggTikgPSAgTlxuICogIHNxcnQoLUkpID0gIE5cbiAqICBzcXJ0KCBJKSA9ICBJXG4gKiAgc3FydCggMCkgPSAgMFxuICogIHNxcnQoLTApID0gLTBcbiAqXG4gKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2ZcbiAqIHRoaXMgQmlnTnVtYmVyLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cbiAqL1xuUFsnc3F1YXJlUm9vdCddID0gUFsnc3FydCddID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuLCByLCByZSwgdCxcbiAgICAgICAgeCA9IHRoaXMsXG4gICAgICAgIGMgPSB4WydjJ10sXG4gICAgICAgIHMgPSB4WydzJ10sXG4gICAgICAgIGUgPSB4WydlJ10sXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXG4gICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERSxcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xuXG4gICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XG4gICAgaWYgKCBzICE9PSAxIHx8ICFjIHx8ICFjWzBdICkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCAhcyB8fCBzIDwgMCAmJiAoICFjIHx8IGNbMF0gKVxuICAgICAgICAgID8gTmFOXG4gICAgICAgICAgOiBjID8geCA6IDEgLyAwICk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cbiAgICBzID0gTWF0aC5zcXJ0KCB4Wyd0b1MnXSgpICk7XG4gICAgUk9VTkRJTkdfTU9ERSA9IDE7XG5cbiAgICAvKlxuICAgICAgTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cbiAgICAgIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgaWYgKCBzID09IDAgfHwgcyA9PSAxIC8gMCApIHtcbiAgICAgICAgbiA9IGMuam9pbignJyk7XG5cbiAgICAgICAgaWYgKCAhKCBuLmxlbmd0aCArIGUgJiAxICkgKSB7XG4gICAgICAgICAgICBuICs9ICcwJztcbiAgICAgICAgfVxuICAgICAgICByID0gbmV3IEJpZ051bWJlciggTWF0aC5zcXJ0KG4pICsgJycgKTtcblxuICAgICAgICAvLyByIG1heSBzdGlsbCBub3QgYmUgZmluaXRlLlxuICAgICAgICBpZiAoICFyWydjJ10gKSB7XG4gICAgICAgICAgICByWydjJ10gPSBbMV07XG4gICAgICAgIH1cbiAgICAgICAgclsnZSddID0gKCAoICggZSArIDEgKSAvIDIgKSB8IDAgKSAtICggZSA8IDAgfHwgZSAmIDEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByID0gbmV3IEJpZ051bWJlciggbiA9IHMudG9TdHJpbmcoKSApO1xuICAgIH1cbiAgICByZSA9IHJbJ2UnXTtcbiAgICBzID0gcmUgKyAoIERFQ0lNQUxfUExBQ0VTICs9IDQgKTtcblxuICAgIGlmICggcyA8IDMgKSB7XG4gICAgICAgIHMgPSAwO1xuICAgIH1cbiAgICBlID0gcztcblxuICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cbiAgICBmb3IgKCA7IDsgKSB7XG4gICAgICAgIHQgPSByO1xuICAgICAgICByID0gaGFsZlsndGltZXMnXSggdFsncGx1cyddKCB4WydkaXYnXSh0KSApICk7XG5cbiAgICAgICAgaWYgKCB0WydjJ10uc2xpY2UoIDAsIHMgKS5qb2luKCcnKSA9PT0gclsnYyddLnNsaWNlKCAwLCBzICkuam9pbignJykgKSB7XG4gICAgICAgICAgICBjID0gclsnYyddO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICAgICAgZXhwb25lbnQgKHJlKSwgZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdFxuICAgICAgICAgICAgICBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzID0gcyAtICggbiAmJiByWydlJ10gPCByZSApO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZ1xuICAgICAgICAgICAgICBkaWdpdHMgYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KVxuICAgICAgICAgICAgICBjb250aW51ZSB0aGUgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIGNbc10gPT0gOSAmJiBjW3MgLSAxXSA9PSA5ICYmIGNbcyAtIDJdID09IDkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCBjW3MgLSAzXSA9PSA5IHx8IG4gJiYgY1tzIC0gM10gPT0gNCApICkge1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgIElmIDk5OTkgb24gZmlyc3QgcnVuIHRocm91Z2gsIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cFxuICAgICAgICAgICAgICAgICAgZ2l2ZXMgdGhlIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICggbiAmJiBjW3MgLSAzXSA9PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gclsncm91bmQnXSggZHAsIDAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRbJ3RpbWVzJ10odClbJ2VxJ10oeCkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBST1VORElOR19NT0RFID0gcm07XG4gICAgICAgICAgICAgICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IGRwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBERUNJTUFMX1BMQUNFUyArPSA0O1xuICAgICAgICAgICAgICAgIHMgKz0gNDtcbiAgICAgICAgICAgICAgICBuID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgIElmIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDAwMDAgb3IgNTAwMCwgY2hlY2sgZm9yIGFuXG4gICAgICAgICAgICAgICAgICBleGFjdCByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgc29cbiAgICAgICAgICAgICAgICAgIGluY3JlbWVudCB0aGUgMXN0IHJvdW5kaW5nIGRpZ2l0IHRvIGVuc3VyZSBjb3JyZWN0IHJvdW5kaW5nLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICggIWNbZV0gJiYgIWNbZSAtIDFdICYmICFjW2UgLSAyXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAhY1tlIC0gM10gfHwgY1tlIC0gM10gPT0gNSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjLmxlbmd0aCA+IGUgLSAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5sZW5ndGggPSBlIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXJbJ3RpbWVzJ10ocilbJ2VxJ10oeCkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggYy5sZW5ndGggPCBlIC0gMyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjW2UgLSAzXSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSBybTtcbiAgICAgICAgICAgICAgICBybmQoIHIsIERFQ0lNQUxfUExBQ0VTID0gZHAsIDEwICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLypcbiAqICBuICogMCA9IDBcbiAqICBuICogTiA9IE5cbiAqICBuICogSSA9IElcbiAqICAwICogbiA9IDBcbiAqICAwICogMCA9IDBcbiAqICAwICogTiA9IE5cbiAqICAwICogSSA9IE5cbiAqICBOICogbiA9IE5cbiAqICBOICogMCA9IE5cbiAqICBOICogTiA9IE5cbiAqICBOICogSSA9IE5cbiAqICBJICogbiA9IElcbiAqICBJICogMCA9IE5cbiAqICBJICogTiA9IE5cbiAqICBJICogSSA9IElcbiAqXG4gKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciB0aW1lc1xuICogdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cbiAqL1xuUFsndGltZXMnXSA9IFBbJ211bCddID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgIHZhciBjLFxuICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgeGMgPSB4WydjJ10sXG4gICAgICAgIHljID0gKCBpZCA9IDExLCB5ID0gbmV3IEJpZ051bWJlciggeSwgYiApIClbJ2MnXSxcbiAgICAgICAgaSA9IHhbJ2UnXSxcbiAgICAgICAgaiA9IHlbJ2UnXSxcbiAgICAgICAgYSA9IHhbJ3MnXTtcblxuICAgIHlbJ3MnXSA9IGEgPT0gKCBiID0geVsncyddICkgPyAxIDogLTE7XG5cbiAgICAvLyBFaXRoZXIgTmFOL0luZmluaXR5LzA/XG4gICAgaWYgKCAhaSAmJiAoICF4YyB8fCAheGNbMF0gKSB8fCAhaiAmJiAoICF5YyB8fCAheWNbMF0gKSApIHtcblxuICAgICAgICAvLyBFaXRoZXIgTmFOP1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggIWEgfHwgIWIgfHxcblxuICAgICAgICAgIC8vIHggaXMgMCBhbmQgeSBpcyBJbmZpbml0eSAgb3IgIHkgaXMgMCBhbmQgeCBpcyBJbmZpbml0eT9cbiAgICAgICAgICB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGNcblxuICAgICAgICAgICAgLy8gUmV0dXJuIE5hTi5cbiAgICAgICAgICAgID8gTmFOXG5cbiAgICAgICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cbiAgICAgICAgICAgIDogIXhjIHx8ICF5Y1xuXG4gICAgICAgICAgICAgIC8vIFJldHVybiArLUluZmluaXR5LlxuICAgICAgICAgICAgICA/IHlbJ3MnXSAvIDBcblxuICAgICAgICAgICAgICAvLyB4IG9yIHkgaXMgMC4gUmV0dXJuICstMC5cbiAgICAgICAgICAgICAgOiB5WydzJ10gKiAwICk7XG4gICAgfVxuICAgIHlbJ2UnXSA9IGkgKyBqO1xuXG4gICAgaWYgKCAoIGEgPSB4Yy5sZW5ndGggKSA8ICggYiA9IHljLmxlbmd0aCApICkge1xuICAgICAgICBjID0geGMsIHhjID0geWMsIHljID0gYywgaiA9IGEsIGEgPSBiLCBiID0gajtcbiAgICB9XG5cbiAgICBmb3IgKCBqID0gYSArIGIsIGMgPSBbXTsgai0tOyBjLnB1c2goMCkgKSB7XG4gICAgfVxuXG4gICAgLy8gTXVsdGlwbHkhXG4gICAgZm9yICggaSA9IGIgLSAxOyBpID4gLTE7IGktLSApIHtcblxuICAgICAgICBmb3IgKCBiID0gMCwgaiA9IGEgKyBpO1xuICAgICAgICAgICAgICBqID4gaTtcbiAgICAgICAgICAgICAgYiA9IGNbal0gKyB5Y1tpXSAqIHhjW2ogLSBpIC0gMV0gKyBiLFxuICAgICAgICAgICAgICBjW2otLV0gPSBiICUgMTAgfCAwLFxuICAgICAgICAgICAgICBiID0gYiAvIDEwIHwgMCApIHtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYiApIHtcbiAgICAgICAgICAgIGNbal0gPSAoIGNbal0gKyBiICkgJSAxMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGIgJiYgKyt5WydlJ107XG5cbiAgICAvLyBSZW1vdmUgYW55IGxlYWRpbmcgemVyby5cbiAgICAhY1swXSAmJiBjLnNoaWZ0KCk7XG5cbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXG4gICAgZm9yICggaiA9IGMubGVuZ3RoOyAhY1stLWpdOyBjLnBvcCgpICkge1xuICAgIH1cblxuICAgIC8vIE5vIHplcm8gY2hlY2sgbmVlZGVkIGFzIG9ubHkgeCAqIDAgPT0gMCBldGMuXG5cbiAgICAvLyBPdmVyZmxvdz9cbiAgICB5WydjJ10gPSB5WydlJ10gPiBNQVhfRVhQXG5cbiAgICAgIC8vIEluZmluaXR5LlxuICAgICAgPyAoIHlbJ2UnXSA9IG51bGwgKVxuXG4gICAgICAvLyBVbmRlcmZsb3c/XG4gICAgICA6IHlbJ2UnXSA8IE1JTl9FWFBcblxuICAgICAgICAvLyBaZXJvLlxuICAgICAgICA/IFsgeVsnZSddID0gMCBdXG5cbiAgICAgICAgLy8gTmVpdGhlci5cbiAgICAgICAgOiBjO1xuXG4gICAgcmV0dXJuIHk7XG59O1xuXG4vKlxuICogUmV0dXJuIGEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIFxuICovXG5QWyd0b0J1ZmZlciddID0gZnVuY3Rpb24gKCBvcHRzICkge1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob3B0cyAhPT0gJ21waW50JykgcmV0dXJuICdVbnN1cHBvcnRlZCBCdWZmZXIgcmVwcmVzZW50YXRpb24nO1xuXG4gICAgICAgIHZhciBhYnMgPSB0aGlzLmFicygpO1xuICAgICAgICB2YXIgYnVmID0gYWJzLnRvQnVmZmVyKHsgc2l6ZSA6IDEsIGVuZGlhbiA6ICdiaWcnIH0pO1xuICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCA9PT0gMSAmJiBidWZbMF0gPT09IDAgPyAwIDogYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKGJ1ZlswXSAmIDB4ODApIGxlbiArKztcblxuICAgICAgICB2YXIgcmV0ID0gbmV3IEJ1ZmZlcig0ICsgbGVuKTtcbiAgICAgICAgaWYgKGxlbiA+IDApIGJ1Zi5jb3B5KHJldCwgNCArIChidWZbMF0gJiAweDgwID8gMSA6IDApKTtcbiAgICAgICAgaWYgKGJ1ZlswXSAmIDB4ODApIHJldFs0XSA9IDA7XG5cbiAgICAgICAgcmV0WzBdID0gbGVuICYgKDB4ZmYgPDwgMjQpO1xuICAgICAgICByZXRbMV0gPSBsZW4gJiAoMHhmZiA8PCAxNik7XG4gICAgICAgIHJldFsyXSA9IGxlbiAmICgweGZmIDw8IDgpO1xuICAgICAgICByZXRbM10gPSBsZW4gJiAoMHhmZiA8PCAwKTtcblxuICAgICAgICAvLyB0d28ncyBjb21wbGltZW50IGZvciBuZWdhdGl2ZSBpbnRlZ2VyczpcbiAgICAgICAgdmFyIGlzTmVnID0gdGhpcy5sdCgwKTtcbiAgICAgICAgaWYgKGlzTmVnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gNDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJldFtpXSA9IDB4ZmYgLSByZXRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0WzRdID0gKHJldFs0XSAmIDB4N2YpIHwgKGlzTmVnID8gMHg4MCA6IDApO1xuICAgICAgICBpZiAoaXNOZWcpIHJldFtyZXQubGVuZ3RoIC0gMV0gKys7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcblxuICAgIHZhciBlbmRpYW4gPSB7IDEgOiAnYmlnJywgJy0xJyA6ICdsaXR0bGUnIH1bb3B0cy5lbmRpYW5dXG4gICAgICAgIHx8IG9wdHMuZW5kaWFuIHx8ICdiaWcnXG4gICAgO1xuXG4gICAgdmFyIGhleCA9IHRoaXMudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXguY2hhckF0KDApID09PSAnLScpIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2NvbnZlcnRpbmcgbmVnYXRpdmUgbnVtYmVycyB0byBCdWZmZXJzIG5vdCBzdXBwb3J0ZWQgeWV0J1xuICAgICk7XG5cbiAgICB2YXIgc2l6ZSA9IG9wdHMuc2l6ZSA9PT0gJ2F1dG8nID8gTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSA6IChvcHRzLnNpemUgfHwgMSk7XG5cbiAgICB2YXIgbGVuID0gTWF0aC5jZWlsKGhleC5sZW5ndGggLyAoMiAqIHNpemUpKSAqIHNpemU7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuKTtcblxuICAgIC8vIHplcm8tcGFkIHRoZSBoZXggc3RyaW5nIHNvIHRoZSBjaHVua3MgYXJlIGFsbCBgc2l6ZWAgbG9uZ1xuICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgMiAqIGxlbikgaGV4ID0gJzAnICsgaGV4O1xuXG4gICAgdmFyIGh4ID0gaGV4XG4gICAgICAgIC5zcGxpdChuZXcgUmVnRXhwKCcoLnsnICsgKDIgKiBzaXplKSArICd9KScpKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmxlbmd0aCA+IDAgfSlcbiAgICA7XG5cbiAgICBoeC5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaywgaSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemU7IGorKykge1xuICAgICAgICAgICAgdmFyIGl4ID0gaSAqIHNpemUgKyAoZW5kaWFuID09PSAnYmlnJyA/IGogOiBzaXplIC0gaiAtIDEpO1xuICAgICAgICAgICAgYnVmW2l4XSA9IHBhcnNlSW50KGNodW5rLnNsaWNlKGoqMixqKjIrMiksIDE2KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8qXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbFxuICogbm90YXRpb24gdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgYW5kIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSBpZlxuICogbmVjZXNzYXJ5LlxuICpcbiAqIFtkcF0ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxuICovXG5QWyd0b0V4cG9uZW50aWFsJ10gPSBQWyd0b0UnXSA9IGZ1bmN0aW9uICggZHAgKSB7XG5cbiAgICByZXR1cm4gZm9ybWF0KCB0aGlzLFxuICAgICAgKCBkcCA9PSBudWxsIHx8ICggKCBvdXRPZlJhbmdlID0gZHAgPCAwIHx8IGRwID4gTUFYICkgfHxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJbmNsdWRlICcmJiBkcCAhPT0gMCcgYmVjYXVzZSB3aXRoIE9wZXJhIC0wID09IHBhcnNlRmxvYXQoLTApIGlzXG4gICAgICAgICAqIGZhbHNlLCBkZXNwaXRlIC0wID09IHBhcnNlRmxvYXQoJy0wJykgJiYgMCA9PSAtMCBiZWluZyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2UoZHApICE9IGRwICYmIGRwICE9PSAwICkgJiZcblxuICAgICAgICAgIC8vICd0b0UoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcbiAgICAgICAgICAvLyAndG9FKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xuICAgICAgICAgICFpZkV4Y2VwdGlvbnNUaHJvdyggZHAsICdkZWNpbWFsIHBsYWNlcycsICd0b0UnICkgKSAmJiB0aGlzWydjJ11cbiAgICAgICAgICAgID8gdGhpc1snYyddLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIDogZHAgfCAwLCAxICk7XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBub3JtYWxcbiAqIG5vdGF0aW9uIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIGFuZCByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgaWZcbiAqIG5lY2Vzc2FyeS5cbiAqXG4gKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcbiAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxuICpcbiAqIFtkcF0ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxuICovXG5QWyd0b0ZpeGVkJ10gPSBQWyd0b0YnXSA9IGZ1bmN0aW9uICggZHAgKSB7XG4gICAgdmFyIG4sIHN0ciwgZCxcbiAgICAgICAgeCA9IHRoaXM7XG5cbiAgICBpZiAoICEoIGRwID09IG51bGwgfHwgKCAoIG91dE9mUmFuZ2UgPSBkcCA8IDAgfHwgZHAgPiBNQVggKSB8fFxuICAgICAgICBwYXJzZShkcCkgIT0gZHAgJiYgZHAgIT09IDAgKSAmJlxuXG4gICAgICAgIC8vICd0b0YoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcbiAgICAgICAgLy8gJ3RvRigpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcbiAgICAgICAgIWlmRXhjZXB0aW9uc1Rocm93KCBkcCwgJ2RlY2ltYWwgcGxhY2VzJywgJ3RvRicgKSApICkge1xuICAgICAgICAgIGQgPSB4WydlJ10gKyAoIGRwIHwgMCApO1xuICAgIH1cblxuICAgIG4gPSBUT19FWFBfTkVHLCBkcCA9IFRPX0VYUF9QT1M7XG4gICAgVE9fRVhQX05FRyA9IC0oIFRPX0VYUF9QT1MgPSAxIC8gMCApO1xuXG4gICAgLy8gTm90ZTogc3RyIGlzIGluaXRpYWxseSB1bmRlZmluZWQuXG4gICAgaWYgKCBkID09IHN0ciApIHtcbiAgICAgICAgc3RyID0geFsndG9TJ10oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXQoIHgsIGQgKTtcblxuICAgICAgICAvLyAoLTApLnRvRml4ZWQoKSBpcyAnMCcsIGJ1dCAoLTAuMSkudG9GaXhlZCgpIGlzICctMCcuXG4gICAgICAgIC8vICgtMCkudG9GaXhlZCgxKSBpcyAnMC4wJywgYnV0ICgtMC4wMSkudG9GaXhlZCgxKSBpcyAnLTAuMCcuXG4gICAgICAgIGlmICggeFsncyddIDwgMCAmJiB4WydjJ10gKSB7XG5cbiAgICAgICAgICAgIC8vIEFzIGUuZy4gLTAgdG9GaXhlZCgzKSwgd2lsbCB3cm9uZ2x5IGJlIHJldHVybmVkIGFzIC0wLjAwMCBmcm9tIHRvU3RyaW5nLlxuICAgICAgICAgICAgaWYgKCAheFsnYyddWzBdICkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eLS8sICcnKTtcblxuICAgICAgICAgICAgLy8gQXMgZS5nLiAtMC41IGlmIHJvdW5kZWQgdG8gLTAgd2lsbCBjYXVzZSB0b1N0cmluZyB0byBvbWl0IHRoZSBtaW51cyBzaWduLlxuICAgICAgICAgICAgfSBlbHNlIGlmICggc3RyLmluZGV4T2YoJy0nKSA8IDAgKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFRPX0VYUF9ORUcgPSBuLCBUT19FWFBfUE9TID0gZHA7XG5cbiAgICByZXR1cm4gc3RyO1xufTtcblxuXG4vKlxuICogUmV0dXJuIGEgc3RyaW5nIGFycmF5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYVxuICogc2ltcGxlIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXG4gKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICogdGhlIHNwZWNpZmllZCBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90XG4gKiBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvXG4gKiByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxuICpcbiAqIFttYXhEXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSBhbmQgPCBJbmZpbml0eS5cbiAqL1xuUFsndG9GcmFjdGlvbiddID0gUFsndG9GciddID0gZnVuY3Rpb24gKCBtYXhEICkge1xuICAgIHZhciBxLCBmcmFjLCBuMCwgZDAsIGQyLCBuLCBlLFxuICAgICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpLFxuICAgICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcignMCcpLFxuICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgeGMgPSB4WydjJ10sXG4gICAgICAgIGV4cCA9IE1BWF9FWFAsXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXG4gICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERSxcbiAgICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcblxuICAgIC8vIE5hTiwgSW5maW5pdHkuXG4gICAgaWYgKCAheGMgKSB7XG4gICAgICAgIHJldHVybiB4Wyd0b1MnXSgpO1xuICAgIH1cblxuICAgIGUgPSBkWydlJ10gPSB4Yy5sZW5ndGggLSB4WydlJ10gLSAxO1xuXG4gICAgLy8gSWYgbWF4IGRlbm9taW5hdG9yIGlzIHVuZGVmaW5lZCBvciBudWxsLi4uXG4gICAgaWYgKCBtYXhEID09IG51bGwgfHxcblxuICAgICAgICAgLy8gb3IgTmFOLi4uXG4gICAgICAgICAoICEoIGlkID0gMTIsIG4gPSBuZXcgQmlnTnVtYmVyKG1heEQpIClbJ3MnXSB8fFxuXG4gICAgICAgICAgIC8vIG9yIGxlc3MgdGhhbiAxLCBvciBJbmZpbml0eS4uLlxuICAgICAgICAgICAoIG91dE9mUmFuZ2UgPSBuWydjbXAnXShuMSkgPCAwIHx8ICFuWydjJ10gKSB8fFxuXG4gICAgICAgICAgICAgLy8gb3Igbm90IGFuIGludGVnZXIuLi5cbiAgICAgICAgICAgICAoIEVSUk9SUyAmJiBuWydlJ10gPCBuWydjJ10ubGVuZ3RoIC0gMSApICkgJiZcblxuICAgICAgICAgICAgICAgLy8gJ3RvRnIoKSBtYXggZGVub21pbmF0b3Igbm90IGFuIGludGVnZXI6IHttYXhEfSdcbiAgICAgICAgICAgICAgIC8vICd0b0ZyKCkgbWF4IGRlbm9taW5hdG9yIG91dCBvZiByYW5nZToge21heER9J1xuICAgICAgICAgICAgICAgIWlmRXhjZXB0aW9uc1Rocm93KCBtYXhELCAnbWF4IGRlbm9taW5hdG9yJywgJ3RvRnInICkgfHxcblxuICAgICAgICAgICAgICAgICAvLyBvciBncmVhdGVyIHRoYW4gdGhlIG1heEQgbmVlZGVkIHRvIHNwZWNpZnkgdGhlIHZhbHVlIGV4YWN0bHkuLi5cbiAgICAgICAgICAgICAgICAgKCBtYXhEID0gbiApWydjbXAnXShkKSA+IDAgKSB7XG5cbiAgICAgICAgLy8gZCBpcyBlLmcuIDEwLCAxMDAsIDEwMDAsIDEwMDAwLi4uICwgbjEgaXMgMS5cbiAgICAgICAgbWF4RCA9IGUgPiAwID8gZCA6IG4xO1xuICAgIH1cblxuICAgIE1BWF9FWFAgPSAxIC8gMDtcbiAgICBuID0gbmV3IEJpZ051bWJlciggeGMuam9pbignJykgKTtcblxuICAgIGZvciAoIERFQ0lNQUxfUExBQ0VTID0gMCwgUk9VTkRJTkdfTU9ERSA9IDE7IDsgKSAge1xuICAgICAgICBxID0gblsnZGl2J10oZCk7XG4gICAgICAgIGQyID0gZDBbJ3BsdXMnXSggcVsndGltZXMnXShkMSkgKTtcblxuICAgICAgICBpZiAoIGQyWydjbXAnXShtYXhEKSA9PSAxICkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkMCA9IGQxLCBkMSA9IGQyO1xuXG4gICAgICAgIG4xID0gbjBbJ3BsdXMnXSggcVsndGltZXMnXSggZDIgPSBuMSApICk7XG4gICAgICAgIG4wID0gZDI7XG5cbiAgICAgICAgZCA9IG5bJ21pbnVzJ10oIHFbJ3RpbWVzJ10oIGQyID0gZCApICk7XG4gICAgICAgIG4gPSBkMjtcbiAgICB9XG5cbiAgICBkMiA9IG1heERbJ21pbnVzJ10oZDApWydkaXYnXShkMSk7XG4gICAgbjAgPSBuMFsncGx1cyddKCBkMlsndGltZXMnXShuMSkgKTtcbiAgICBkMCA9IGQwWydwbHVzJ10oIGQyWyd0aW1lcyddKGQxKSApO1xuXG4gICAgbjBbJ3MnXSA9IG4xWydzJ10gPSB4WydzJ107XG5cbiAgICBERUNJTUFMX1BMQUNFUyA9IGUgKiAyO1xuICAgIFJPVU5ESU5HX01PREUgPSBybTtcblxuICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAgLyBkMCBvciBuMSAvIGQxP1xuICAgIGZyYWMgPSBuMVsnZGl2J10oZDEpWydtaW51cyddKHgpWydhYnMnXSgpWydjbXAnXShcbiAgICAgIG4wWydkaXYnXShkMClbJ21pbnVzJ10oeClbJ2FicyddKCkgKSA8IDFcbiAgICAgID8gWyBuMVsndG9TJ10oKSwgZDFbJ3RvUyddKCkgXVxuICAgICAgOiBbIG4wWyd0b1MnXSgpLCBkMFsndG9TJ10oKSBdO1xuXG4gICAgcmV0dXJuIE1BWF9FWFAgPSBleHAsIERFQ0lNQUxfUExBQ0VTID0gZHAsIGZyYWM7XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciB0byBzZCBzaWduaWZpY2FudFxuICogZGlnaXRzIGFuZCByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgaWYgbmVjZXNzYXJ5LlxuICogSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcbiAqIHBhcnQgb2YgdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbiwgdGhlbiB1c2UgZXhwb25lbnRpYWwgbm90YXRpb24uXG4gKlxuICogc2Qge251bWJlcn0gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxuICovXG5QWyd0b1ByZWNpc2lvbiddID0gUFsndG9QJ10gPSBmdW5jdGlvbiAoIHNkICkge1xuXG4gICAgLypcbiAgICAgKiBFUlJPUlMgdHJ1ZTogVGhyb3cgaWYgc2Qgbm90IHVuZGVmaW5lZCwgbnVsbCBvciBhbiBpbnRlZ2VyIGluIHJhbmdlLlxuICAgICAqIEVSUk9SUyBmYWxzZTogSWdub3JlIHNkIGlmIG5vdCBhIG51bWJlciBvciBub3QgaW4gcmFuZ2UuXG4gICAgICogVHJ1bmNhdGUgbm9uLWludGVnZXJzLlxuICAgICAqL1xuICAgIHJldHVybiBzZCA9PSBudWxsIHx8ICggKCAoIG91dE9mUmFuZ2UgPSBzZCA8IDEgfHwgc2QgPiBNQVggKSB8fFxuICAgICAgcGFyc2Uoc2QpICE9IHNkICkgJiZcblxuICAgICAgICAvLyAndG9QKCkgcHJlY2lzaW9uIG5vdCBhbiBpbnRlZ2VyOiB7c2R9J1xuICAgICAgICAvLyAndG9QKCkgcHJlY2lzaW9uIG91dCBvZiByYW5nZToge3NkfSdcbiAgICAgICAgIWlmRXhjZXB0aW9uc1Rocm93KCBzZCwgJ3ByZWNpc2lvbicsICd0b1AnICkgKVxuICAgICAgICAgID8gdGhpc1sndG9TJ10oKVxuICAgICAgICAgIDogZm9ybWF0KCB0aGlzLCAtLXNkIHwgMCwgMiApO1xufTtcblxuXG4vKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvclxuICogYmFzZSAxMCBpZiBiIGlzIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLFxuICogcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxuICogSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxuICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbFxuICogdG8gb3IgbGVzcyB0aGFuIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAqXG4gKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byA2NCBpbmNsdXNpdmUuXG4gKi9cblBbJ3RvU3RyaW5nJ10gPSBQWyd0b1MnXSA9IGZ1bmN0aW9uICggYiApIHtcbiAgICB2YXIgdSwgc3RyLCBzdHJMLFxuICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgeGUgPSB4WydlJ107XG5cbiAgICAvLyBJbmZpbml0eSBvciBOYU4/XG4gICAgaWYgKCB4ZSA9PT0gbnVsbCApIHtcbiAgICAgICAgc3RyID0geFsncyddID8gJ0luZmluaXR5JyA6ICdOYU4nO1xuXG4gICAgLy8gRXhwb25lbnRpYWwgZm9ybWF0P1xuICAgIH0gZWxzZSBpZiAoIGIgPT09IHUgJiYgKCB4ZSA8PSBUT19FWFBfTkVHIHx8IHhlID49IFRPX0VYUF9QT1MgKSApIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCggeCwgeFsnYyddLmxlbmd0aCAtIDEsIDEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSB4WydjJ10uam9pbignJyk7XG5cbiAgICAgICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XG4gICAgICAgIGlmICggeGUgPCAwICkge1xuXG4gICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zLlxuICAgICAgICAgICAgZm9yICggOyArK3hlOyBzdHIgPSAnMCcgKyBzdHIgKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xuXG4gICAgICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50P1xuICAgICAgICB9IGVsc2UgaWYgKCBzdHJMID0gc3RyLmxlbmd0aCwgeGUgPiAwICkge1xuXG4gICAgICAgICAgICBpZiAoICsreGUgPiBzdHJMICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zLlxuICAgICAgICAgICAgICAgIGZvciAoIHhlIC09IHN0ckw7IHhlLS0gOyBzdHIgKz0gJzAnICkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHhlIDwgc3RyTCApIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoIDAsIHhlICkgKyAnLicgKyBzdHIuc2xpY2UoeGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cG9uZW50IHplcm8uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIHUgPSBzdHIuY2hhckF0KDApLCBzdHJMID4gMSApIHtcbiAgICAgICAgICAgICAgICBzdHIgPSB1ICsgJy4nICsgc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICAvLyBBdm9pZCAnLTAnXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB1ID09ICcwJyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYiAhPSBudWxsICkge1xuXG4gICAgICAgICAgICBpZiAoICEoIG91dE9mUmFuZ2UgPSAhKCBiID49IDIgJiYgYiA8IDY1ICkgKSAmJlxuICAgICAgICAgICAgICAoIGIgPT0gKGIgfCAwKSB8fCAhRVJST1JTICkgKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gY29udmVydCggc3RyLCBiIHwgMCwgMTAsIHhbJ3MnXSApO1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgJy0wJ1xuICAgICAgICAgICAgICAgIGlmICggc3RyID09ICcwJyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gJ3RvUygpIGJhc2Ugbm90IGFuIGludGVnZXI6IHtifSdcbiAgICAgICAgICAgICAgICAvLyAndG9TKCkgYmFzZSBvdXQgb2YgcmFuZ2U6IHtifSdcbiAgICAgICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggYiwgJ2Jhc2UnLCAndG9TJyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4geFsncyddIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcbn07XG5cblxuLypcbiAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LlxuICovXG5QWyd2YWx1ZU9mJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbJ3RvUyddKCk7XG59O1xuXG5cbi8vIEFkZCBhbGlhc2VzIGZvciBCaWdEZWNpbWFsIG1ldGhvZHMuXG4vL1BbJ2FkZCddID0gUFsncGx1cyddO1xuLy9QWydzdWJ0cmFjdCddID0gUFsnbWludXMnXTtcbi8vUFsnbXVsdGlwbHknXSA9IFBbJ3RpbWVzJ107XG4vL1BbJ2RpdmlkZSddID0gUFsnZGl2J107XG4vL1BbJ3JlbWFpbmRlciddID0gUFsnbW9kJ107XG4vL1BbJ2NvbXBhcmVUbyddID0gUFsnY21wJ107XG4vL1BbJ25lZ2F0ZSddID0gUFsnbmVnJ107XG5cblxuLy8gRVhQT1JUXG5tb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/browserify-bignum/bignumber.js\n");

/***/ })

};
;