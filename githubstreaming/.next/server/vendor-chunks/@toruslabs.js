"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toruslabs";
exports.ids = ["vendor-chunks/@toruslabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   derivePadded: () => (/* binding */ derivePadded),\n/* harmony export */   deriveUnpadded: () => (/* binding */ deriveUnpadded),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generatePrivate: () => (/* binding */ generatePrivate),\n/* harmony export */   getPublic: () => (/* binding */ getPublic),\n/* harmony export */   getPublicCompressed: () => (/* binding */ getPublicCompressed),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_1__.ec(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst browserCrypto = global.crypto || global.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  const arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(size));\n  }\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (subtle) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\") {\n      const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\") {\n      const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (subtle) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n\n\n//# sourceMappingURL=eccrypto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9lY2NyeXB0by9kaXN0L2VjY3J5cHRvLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNNOztBQUV0QyxlQUFlLHdDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQiw0REFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1Qiw4REFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpSTtBQUNqSSIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1YnN0cmVhbWluZy8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2VjY3J5cHRvL2Rpc3QvZWNjcnlwdG8uZXNtLmpzPzg4ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGVjIGFzIGVjJDEgfSBmcm9tICdlbGxpcHRpYyc7XG5cbmNvbnN0IGVjID0gbmV3IGVjJDEoXCJzZWNwMjU2azFcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgYnJvd3NlckNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvIHx8IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuY29uc3QgRUNfR1JPVVBfT1JERVIgPSBCdWZmZXIuZnJvbShcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIiwgXCJoZXhcIik7XG5jb25zdCBaRVJPMzIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTY2FsYXIoeCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHgpICYmIHgubGVuZ3RoID09PSAzMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgaWYgKCFpc1NjYWxhcihwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleS5jb21wYXJlKFpFUk8zMikgPiAwICYmXG4gIC8vID4gMFxuICBwcml2YXRlS2V5LmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMDsgLy8gPCBHXG59XG5cbi8vIENvbXBhcmUgdHdvIGJ1ZmZlcnMgaW4gY29uc3RhbnQgdGltZSB0byBwcmV2ZW50IHRpbWluZyBhdHRhY2tzLlxuZnVuY3Rpb24gZXF1YWxDb25zdFRpbWUoYjEsIGIyKSB7XG4gIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIHJlcyB8PSBiMVtpXSBeIGIyW2ldOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfVxuXG4gIHJldHVybiByZXMgPT09IDA7XG59XG5cbi8qIFRoaXMgbXVzdCBjaGVjayBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlciBvclxubm90LCBzaW5jZSB0aGUgZnVuY3Rpb25zIGFyZSBkaWZmZXJlbnQgYW5kIGRvZXNcbm5vdCBjb252ZXJ0IHVzaW5nIGJyb3dzZXJpZnkgKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKHNpemUpIHtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIGlmICh0eXBlb2YgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obm9kZUNyeXB0by5yYW5kb21CeXRlcyhzaXplKSk7XG4gIH1cbiAgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG59XG5hc3luYyBmdW5jdGlvbiBzaGE1MTIobXNnKSB7XG4gIGlmIChzdWJ0bGUpIHtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbXNnKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGhhc2ggPSBub2RlQ3J5cHRvLmNyZWF0ZUhhc2goXCJzaGE1MTJcIik7XG4gIGNvbnN0IHJlc3VsdCA9IGhhc2gudXBkYXRlKG1zZykuZGlnZXN0KCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZnVuY3Rpb24gZ2V0QWVzKG9wKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXYsIGtleSwgZGF0YSkge1xuICAgIGlmIChzdWJ0bGUpIHtcbiAgICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCJcbiAgICAgIH07XG4gICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW29wXSk7XG4gICAgICBjb25zdCBlbmNBbGdvcml0aG0gPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiLFxuICAgICAgICBpdlxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1YnRsZVtvcF0oZW5jQWxnb3JpdGhtLCBjcnlwdG9LZXksIGRhdGEpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZW5jcnlwdFwiKSB7XG4gICAgICBjb25zdCBjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KFwiYWVzLTI1Ni1jYmNcIiwga2V5LCBpdik7XG4gICAgICBjb25zdCBmaXJzdENodW5rID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgIGNvbnN0IHNlY29uZENodW5rID0gY2lwaGVyLmZpbmFsKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZmlyc3RDaHVuaywgc2Vjb25kQ2h1bmtdKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImRlY3J5cHRcIikge1xuICAgICAgY29uc3QgZGVjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXCJhZXMtMjU2LWNiY1wiLCBrZXksIGl2KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICBjb25zdCBzZWNvbmRDaHVuayA9IGRlY2lwaGVyLmZpbmFsKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZmlyc3RDaHVuaywgc2Vjb25kQ2h1bmtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRpb246ICR7b3B9YCk7XG4gIH07XG59XG5jb25zdCBhZXNDYmNFbmNyeXB0ID0gZ2V0QWVzKFwiZW5jcnlwdFwiKTtcbmNvbnN0IGFlc0NiY0RlY3J5cHQgPSBnZXRBZXMoXCJkZWNyeXB0XCIpO1xuYXN5bmMgZnVuY3Rpb24gaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpIHtcbiAgaWYgKHN1YnRsZSkge1xuICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHtcbiAgICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBcIlNIQS0yNTZcIlxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBuZXcgVWludDhBcnJheShrZXkpLCBpbXBvcnRBbGdvcml0aG0sIGZhbHNlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbiAgICBjb25zdCBzaWcgPSBhd2FpdCBzdWJ0bGUuc2lnbihcIkhNQUNcIiwgY3J5cHRvS2V5LCBtc2cpO1xuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgaG1hYyA9IG5vZGVDcnlwdG8uY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBCdWZmZXIuZnJvbShrZXkpKTtcbiAgaG1hYy51cGRhdGUobXNnKTtcbiAgY29uc3QgcmVzdWx0ID0gaG1hYy5kaWdlc3QoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhtYWNTaGEyNTZWZXJpZnkoa2V5LCBtc2csIHNpZykge1xuICBjb25zdCBleHBlY3RlZFNpZyA9IGF3YWl0IGhtYWNTaGEyNTZTaWduKGtleSwgbXNnKTtcbiAgcmV0dXJuIGVxdWFsQ29uc3RUaW1lKGV4cGVjdGVkU2lnLCBzaWcpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbmV3IHZhbGlkIHByaXZhdGUga2V5LiBXaWxsIHVzZSB0aGUgd2luZG93LmNyeXB0byBvciB3aW5kb3cubXNDcnlwdG8gYXMgc291cmNlXG4gKiBkZXBlbmRpbmcgb24geW91ciBicm93c2VyLlxuICovXG5jb25zdCBnZW5lcmF0ZVByaXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICB3aGlsZSAoIWlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpKSB7XG4gICAgcHJpdmF0ZUtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleTtcbn07XG5jb25zdCBnZXRQdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBzeW5jIEFQSSBzbyB3ZSB0aHJvdyBhbiBlcnJvciBpbW1lZGlhdGVseS5cbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIC8vIFhYWChLYWdhbWkpOiBgZWxsaXB0aWMudXRpbHMuZW5jb2RlYCByZXR1cm5zIGFycmF5IGZvciBldmVyeVxuICAvLyBlbmNvZGluZyBleGNlcHQgYGhleGAuXG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoXCJhcnJheVwiKSk7XG59O1xuXG4vKipcbiAqIEdldCBjb21wcmVzc2VkIHZlcnNpb24gb2YgcHVibGljIGtleS5cbiAqL1xuY29uc3QgZ2V0UHVibGljQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93YW5kZXJlci9zZWNwMjU2azEtbm9kZS9pc3N1ZXMvNDZcbiAgY29uc3QgY29tcHJlc3NlZCA9IHRydWU7XG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoY29tcHJlc3NlZCwgXCJhcnJheVwiKSk7XG59O1xuXG4vLyBOT1RFKEthZ2FtaSk6IFdlIGRvbid0IHVzZSBwcm9taXNlIHNoaW0gaW4gQnJvd3NlciBpbXBsZW1lbnRhdGlvblxuLy8gYmVjYXVzZSBpdCdzIHN1cHBvcnRlZCBuYXRpdmVseSBpbiBuZXcgYnJvd3NlcnMgKHNlZVxuLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1wcm9taXNlcz4pIGFuZCB3ZSBjYW4gdXNlIG9ubHkgbmV3IGJyb3dzZXJzXG4vLyBiZWNhdXNlIG9mIHRoZSBXZWJDcnlwdG9BUEkgKHNlZVxuLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1jcnlwdG9ncmFwaHk+KS5cbmNvbnN0IHNpZ24gPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleSwgbXNnKSB7XG4gIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA+IDAsIFwiTWVzc2FnZSBzaG91bGQgbm90IGJlIGVtcHR5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA8PSAzMiwgXCJNZXNzYWdlIGlzIHRvbyBsb25nXCIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZWMuc2lnbihtc2csIHByaXZhdGVLZXksIHtcbiAgICBjYW5vbmljYWw6IHRydWVcbiAgfSkudG9ERVIoKSk7XG59O1xuY29uc3QgdmVyaWZ5ID0gYXN5bmMgZnVuY3Rpb24gKHB1YmxpY0tleSwgbXNnLCBzaWcpIHtcbiAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleS5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5WzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlbMF0gPT09IDIgfHwgcHVibGljS2V5WzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGFzc2VydChtc2cubGVuZ3RoID4gMCwgXCJNZXNzYWdlIHNob3VsZCBub3QgYmUgZW1wdHlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoIDw9IDMyLCBcIk1lc3NhZ2UgaXMgdG9vIGxvbmdcIik7XG4gIGlmIChlYy52ZXJpZnkobXNnLCBzaWcsIHB1YmxpY0tleSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc2lnbmF0dXJlXCIpO1xufTtcbmNvbnN0IGRlcml2ZSA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5QSwgcHVibGljS2V5Qikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5QiksIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGFzc2VydChwcml2YXRlS2V5QS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Qi5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSAyIHx8IHB1YmxpY0tleUJbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5QSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlBKTtcbiAgY29uc3Qga2V5QiA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5Qik7XG4gIGNvbnN0IFB4ID0ga2V5QS5kZXJpdmUoa2V5Qi5nZXRQdWJsaWMoKSk7IC8vIEJOIGluc3RhbmNlXG4gIHJldHVybiBCdWZmZXIuZnJvbShQeC50b0FycmF5KCkpO1xufTtcbmNvbnN0IGRlcml2ZVVucGFkZGVkID0gZGVyaXZlO1xuY29uc3QgZGVyaXZlUGFkZGVkID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXlBLCBwdWJsaWNLZXlCKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXlCKSwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgYXNzZXJ0KHByaXZhdGVLZXlBLmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDIgfHwgcHVibGljS2V5QlswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlBID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUEpO1xuICBjb25zdCBrZXlCID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXlCKTtcbiAgY29uc3QgUHggPSBrZXlBLmRlcml2ZShrZXlCLmdldFB1YmxpYygpKTsgLy8gQk4gaW5zdGFuY2VcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFB4LnRvU3RyaW5nKDE2LCA2NCksIFwiaGV4XCIpO1xufTtcbmNvbnN0IGVuY3J5cHQgPSBhc3luYyBmdW5jdGlvbiAocHVibGljS2V5VG8sIG1zZywgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgbGV0IGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgLy8gVGhlcmUgaXMgYSB2ZXJ5IHVubGlrZWx5IHBvc3NpYmlsaXR5IHRoYXQgaXQgaXMgbm90IGEgdmFsaWQga2V5XG4gIHdoaWxlICghaXNWYWxpZFByaXZhdGVLZXkoZXBoZW1Qcml2YXRlS2V5KSkge1xuICAgIGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgfVxuICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IGdldFB1YmxpYyhlcGhlbVByaXZhdGVLZXkpO1xuICBjb25zdCBQeCA9IGF3YWl0IGRlcml2ZVVucGFkZGVkKGVwaGVtUHJpdmF0ZUtleSwgcHVibGljS2V5VG8pO1xuICBjb25zdCBoYXNoID0gYXdhaXQgc2hhNTEyKFB4KTtcbiAgY29uc3QgaXYgPSBvcHRzLml2IHx8IHJhbmRvbUJ5dGVzKDE2KTtcbiAgY29uc3QgZW5jcnlwdGlvbktleSA9IGhhc2guc2xpY2UoMCwgMzIpO1xuICBjb25zdCBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGFlc0NiY0VuY3J5cHQoaXYsIEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25LZXkpLCBtc2cpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gZGF0YTtcbiAgY29uc3QgZGF0YVRvTWFjID0gQnVmZmVyLmNvbmNhdChbaXYsIGVwaGVtUHVibGljS2V5LCBjaXBoZXJ0ZXh0XSk7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNTaGEyNTZTaWduKEJ1ZmZlci5mcm9tKG1hY0tleSksIGRhdGFUb01hYyk7XG4gIHJldHVybiB7XG4gICAgaXYsXG4gICAgZXBoZW1QdWJsaWNLZXksXG4gICAgY2lwaGVydGV4dCxcbiAgICBtYWNcbiAgfTtcbn07XG5jb25zdCBkZWNyeXB0ID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXksIG9wdHMsIF9wYWRkaW5nKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSBfcGFkZGluZyAhPT0gbnVsbCAmJiBfcGFkZGluZyAhPT0gdm9pZCAwID8gX3BhZGRpbmcgOiBmYWxzZTtcbiAgY29uc3QgZGVyaXZlTG9jYWwgPSBwYWRkaW5nID8gZGVyaXZlUGFkZGVkIDogZGVyaXZlVW5wYWRkZWQ7XG4gIGNvbnN0IFB4ID0gYXdhaXQgZGVyaXZlTG9jYWwocHJpdmF0ZUtleSwgb3B0cy5lcGhlbVB1YmxpY0tleSk7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBzaGE1MTIoUHgpO1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gaGFzaC5zbGljZSgwLCAzMik7XG4gIGNvbnN0IG1hY0tleSA9IGhhc2guc2xpY2UoMzIpO1xuICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtvcHRzLml2LCBvcHRzLmVwaGVtUHVibGljS2V5LCBvcHRzLmNpcGhlcnRleHRdKTtcbiAgY29uc3QgbWFjR29vZCA9IGF3YWl0IGhtYWNTaGEyNTZWZXJpZnkoQnVmZmVyLmZyb20obWFjS2V5KSwgZGF0YVRvTWFjLCBvcHRzLm1hYyk7XG4gIGlmICghbWFjR29vZCAmJiBwYWRkaW5nID09PSBmYWxzZSkge1xuICAgIHJldHVybiBkZWNyeXB0KHByaXZhdGVLZXksIG9wdHMsIHRydWUpO1xuICB9IGVsc2UgaWYgKCFtYWNHb29kICYmIHBhZGRpbmcgPT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgTUFDIGFmdGVyIHRyeWluZyBwYWRkZWRcIik7XG4gIH1cbiAgY29uc3QgbXNnID0gYXdhaXQgYWVzQ2JjRGVjcnlwdChvcHRzLml2LCBCdWZmZXIuZnJvbShlbmNyeXB0aW9uS2V5KSwgb3B0cy5jaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KG1zZykpO1xufTtcblxuZXhwb3J0IHsgZGVjcnlwdCwgZGVyaXZlLCBkZXJpdmVQYWRkZWQsIGRlcml2ZVVucGFkZGVkLCBlbmNyeXB0LCBnZW5lcmF0ZVByaXZhdGUsIGdldFB1YmxpYywgZ2V0UHVibGljQ29tcHJlc3NlZCwgc2lnbiwgdmVyaWZ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lY2NyeXB0by5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\n");

/***/ })

};
;